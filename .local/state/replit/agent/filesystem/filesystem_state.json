{"file_contents":{"config.js":{"content":"export default {\n  botName: \"Saitama Bot\",\n  ownerName: \"Lord Saitama\",\n  version: \"1.0.0\",\n  sessionFile: \"./session/creds.json\",\n  image: \"assets/media/logo.jpg\",\n};\n","size_bytes":168},"index.js":{"content":"import makeWASocket, { useMultiFileAuthState } from '@whiskeysockets/baileys';\nimport P from \"pino\";\nimport chalk from 'chalk';\nimport qrcode from 'qrcode-terminal';\nimport fs from 'fs';\nimport path from 'path';\nimport menu from \"./commands/menu.js\";\nimport alive from \"./commands/alive.js\";\nimport config from \"./config.js\";\nimport { groupMenu } from \"./commands/group.js\";\nimport muteGroup from \"./commands/mute.js\";\nimport manageMembers from \"./commands/manageMembers.js\";\nimport groupInfo from \"./commands/groupinfo.js\";\nimport tagAll from \"./commands/tagall.js\";\nimport sendLogo from './commands/logo.js';\nimport { warnUser, checkWarnings } from './commands/warnings.js';\nimport antiLink from './commands/antilink.js';\nimport hideTag from './commands/hidetag.js';\nimport { welcomeMessage, goodbyeMessage } from './commands/welcome.js';\nimport funGames from './commands/funGames.js';\nimport downloads from './commands/downloads.js';\nimport aiSearch from './commands/aiSearch.js';\nimport { toggleAlwaysOnline, toggleAutoTyping, handlePresence, maintainOnlineStatus } from './commands/presence.js';\nimport { initializeOwner, hasAccess, isOwner, getAccessDeniedMessage, setPrivateMode, addSudoUser, getModeStatus } from './commands/botmode.js';\n\n// === Bot Banner Display ===\nconst banner = `\n███████╗ █████╗ ██╗████████╗ █████╗ ███╗   ███╗ █████╗ \n██╔════╝██╔══██╗██║╚══██╔══╝██╔══██╗████╗ ████║██╔══██╗\n███████╗███████║██║   ██║   ███████║██╔████╔██║███████║\n╚════██║██╔══██║██║   ██║   ██╔══██║██║╚██╔╝██║██╔══██║\n███████║██║  ██║██║   ██║   ██║  ██║██║ ╚═╝ ██║██║  ██║\n╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝╚═╝  ╚═╝\n              Saitama Bot — Activated ⚡\n`;\n\nconsole.log(chalk.cyanBright(banner));\n\n// === Image Display ===\nconst imagePath = path.join('assets', 'media', 'logo.jpg');\nif (fs.existsSync(imagePath)) {\n  console.log(chalk.green('📸 Displaying Saitama Logo...'));\n  console.log(chalk.gray(`(Image path: ${imagePath})`));\n} else {\n  console.log(chalk.red('⚠️ Logo not found in assets/media/logo.jpg'));\n}\n\n// === Start WhatsApp Connection ===\nasync function startBot() {\n  const { state, saveCreds } = await useMultiFileAuthState('auth_info');\n\n  const sock = makeWASocket({\n    auth: state,\n    browser: ['Saitama Bot', 'Chrome', '1.0.0'],\n    logger: P({ level: 'silent' }),\n    syncFullHistory: false,\n    markOnlineOnConnect: true\n  });\n\n  sock.ev.on('creds.update', saveCreds);\n\n  // Connection updates\n  sock.ev.on('connection.update', async (update) => {\n    const { connection, lastDisconnect, qr } = update;\n\n    if (qr) {\n      console.log(chalk.yellow('\\n📌 Scan this QR code with WhatsApp:\\n'));\n      qrcode.generate(qr, { small: true });\n      console.log(chalk.gray('\\nOr use this pairing code: ' + qr));\n    }\n\n    if (connection === 'open') {\n      console.log(chalk.greenBright('✅ Saitama Bot Connected Successfully!'));\n      console.log(chalk.magentaBright('⚡ Initializing owner...'));\n      initializeOwner(sock);\n      console.log(chalk.cyanBright(`📊 Bot Mode: ${getModeStatus()}`));\n    } else if (connection === 'close') {\n      const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== 401;\n      if (shouldReconnect) {\n        console.log(chalk.yellow('⚠️ Connection closed, reconnecting...'));\n        setTimeout(() => startBot(), 3000); // reconnect after 3 seconds\n      } else {\n        console.log(chalk.red('❌ Connection closed. Please delete auth_info and scan QR again.'));\n      }\n    }\n  });\n\n  // Welcome / Goodbye events\n  sock.ev.on('group-participants.update', async (update) => {\n    for (let participant of update.participants) {\n      if (update.action === 'add') await welcomeMessage(sock, { id: participant });\n      if (update.action === 'remove') await goodbyeMessage(sock, { id: participant });\n    }\n  });\n\n  // Handle incoming messages\n  sock.ev.on('messages.upsert', async (m) => {\n    try {\n      const msg = m.messages[0];\n      \n      if (!msg.message) return;\n      \n      // Ignore protocol messages, notifications, and status updates\n      if (msg.message.protocolMessage || msg.message.senderKeyDistributionMessage) return;\n      \n      const from = msg.key.remoteJid;\n      \n      // Debug: Log message info\n      console.log(chalk.magenta('📨 Message - fromMe:'), msg.key.fromMe, 'from:', from);\n    \n    // Extract text from various message types\n    const text = \n      msg.message.conversation || \n      msg.message.extendedTextMessage?.text || \n      msg.message.imageMessage?.caption || \n      msg.message.videoMessage?.caption || \n      '';\n\n    console.log(chalk.yellow(`[${from}] ${text}`));\n    \n    // Skip if no text\n    if (!text) {\n      console.log(chalk.red('⚠️ No text found in message'));\n      return;\n    }\n\n    // Check if message is a command\n    if (!text.startsWith('.')) return;\n    \n    // Get user JID for access control\n    const userJid = msg.key.participant || msg.key.remoteJid;\n    \n    // === ACCESS CONTROL MIDDLEWARE ===\n    // Allow these commands without restriction\n    const publicCommands = ['.menu', '.alive', '.ping'];\n    const ownerOnlyCommands = ['.private', '.public', '.sudo'];\n    \n    // Messages from the bot owner (fromMe) always have access\n    const isOwnerMessage = msg.key.fromMe || isOwner(userJid);\n    \n    // Check if user has access\n    if (!isOwnerMessage && !publicCommands.includes(text.toLowerCase().split(' ')[0])) {\n      if (!hasAccess(userJid)) {\n        await sock.sendMessage(from, { text: getAccessDeniedMessage() });\n        return;\n      }\n    }\n    \n    // Owner-only commands check\n    if (ownerOnlyCommands.includes(text.toLowerCase().split(' ')[0]) && !isOwnerMessage) {\n      await sock.sendMessage(from, { \n        text: '⛔ *Access Denied*\\n\\n🔐 Only my supreme master can use this command.\\n\\n_Know your place..._ 💪' \n      });\n      return;\n    }\n\n    // === Commands ===\n    switch (true) {\n      case text.toLowerCase() === '.menu':\n        await menu(sock, from, 'main', msg);\n        break;\n\n      case text.toLowerCase() === '.alive':\n        await alive(sock, from);\n        break;\n\n      case text.toLowerCase() === '.logo':\n        await sendLogo(sock, from);\n        break;\n\n      case text.toLowerCase() === '.groupmenu':\n        await menu(sock, from, 'group', msg);\n        break;\n\n      case text.toLowerCase() === '.ping':\n        const frames = ['🏓', '🏓🏓', '🏓🏓🏓', '🏓🏓', '🏓', '✅ Pong! Saitama is active!'];\n        for (let i = 0; i < frames.length; i++) {\n          await sock.sendMessage(from, { text: frames[i] });\n          await new Promise(r => setTimeout(r, 300));\n        }\n        break;\n\n      case text.toLowerCase() === '.alwaysonline':\n      case text.toLowerCase() === '.online':\n        await toggleAlwaysOnline(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.autotyping':\n      case text.toLowerCase() === '.typing':\n        await toggleAutoTyping(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.private':\n        await setPrivateMode(sock, msg, true);\n        break;\n\n      case text.toLowerCase() === '.public':\n        await setPrivateMode(sock, msg, false);\n        break;\n\n      case text.toLowerCase().startsWith('.sudo'):\n        await addSudoUser(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.mute' || text.toLowerCase() === '.unmute':\n        await muteGroup(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.groupinfo':\n        await groupInfo(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.tagall':\n        await tagAll(sock, msg);\n        break;\n\n      case text.toLowerCase().startsWith('.warn'):\n        await warnUser(sock, msg);\n        break;\n\n      case text.toLowerCase().startsWith('.warnings'):\n        await checkWarnings(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.hidetag':\n        await hideTag(sock, msg);\n        break;\n\n      case ['.kick', '.add', '.promote', '.demote', '.ban', '.unban'].includes(text.toLowerCase().split(' ')[0]):\n        await manageMembers(sock, msg);\n        break;\n\n      case ['.truth', '.dare', '.trivia', '.guess', '.tictactoe'].includes(text.toLowerCase()):\n      case text.toLowerCase().startsWith('.spam'):\n      case text.toLowerCase().startsWith('.banbug'):\n        await funGames(sock, msg);\n        break;\n\n      case ['.play', '.song', '.video', '.ytmp4', '.tiktok', '.instagram', '.facebook'].some(cmd => text.toLowerCase().startsWith(cmd)):\n        await downloads(sock, msg);\n        break;\n\n      case ['.gpt', '.cyberai', '.gemini', '.calculator', '.imagine'].some(cmd => text.toLowerCase().startsWith(cmd)):\n        await aiSearch(sock, msg);\n        break;\n    }\n\n      // Anti-link detection\n      if (text.includes('https://') || text.includes('www.')) await antiLink(sock, msg);\n    } catch (error) {\n      console.log(chalk.red('Error handling message:'), error.message);\n    }\n  });\n}\n\nstartBot();\n","size_bytes":9504},"replit.md":{"content":"# Saitama Bot - WhatsApp Multi-Function Bot\n\n## Overview\nSaitama Bot is a multi-function WhatsApp bot built with Node.js and the Baileys library. The bot provides various commands for group management, games, downloads, AI interactions, and more.\n\n**Current State**: Configured and ready to run on Replit environment  \n**Last Updated**: October 7, 2025\n\n## Project Architecture\n\n### Technology Stack\n- **Runtime**: Node.js 20\n- **Main Library**: @whiskeysockets/baileys (WhatsApp Web API)\n- **Dependencies**: \n  - chalk (terminal styling)\n  - qrcode-terminal (QR code display)\n  - nodemon (development auto-reload)\n\n### Project Structure\n```\n.\n├── assets/\n│   ├── media/          # Bot logo and media files\n│   └── menu/           # Menu text files\n├── commands/           # All bot command handlers\n│   ├── aiSearch.js     # AI-powered search commands\n│   ├── alive.js        # Alive check\n│   ├── antilink.js     # Anti-link protection\n│   ├── downloads.js    # Download commands (YouTube, TikTok, etc.)\n│   ├── funGames.js     # Fun game commands\n│   ├── group.js        # Group management commands\n│   ├── groupinfo.js    # Group information\n│   ├── help.js         # Help command\n│   ├── hidetag.js      # Hide tag command\n│   ├── logo.js         # Send logo command\n│   ├── manageMembers.js # Member management (kick, add, promote, etc.)\n│   ├── menu.js         # Main menu\n│   ├── mute.js         # Mute/unmute group\n│   ├── ping.js         # Ping command\n│   ├── sticker.js      # Sticker creation\n│   ├── tagall.js       # Tag all members\n│   ├── warnings.js     # Warning system\n│   └── welcome.js      # Welcome/goodbye messages\n├── session/            # WhatsApp session data (gitignored)\n├── utils/              # Utility functions\n│   ├── handler.js      # Message handler utilities\n│   └── logger.js       # Logging utilities\n├── config.js           # Bot configuration\n└── index.js            # Main entry point\n```\n\n## How It Works\n\n### Authentication\nThe bot uses WhatsApp Web's multi-device authentication. On first run:\n1. A QR code is displayed in the console\n2. Scan it with WhatsApp on your phone\n3. Session credentials are saved to `auth_info/` folder\n4. Subsequent runs auto-connect using saved credentials\n\n### Command System\nThe bot listens for messages and responds to commands starting with `.` (dot prefix):\n\n**General Commands**:\n- `.menu` - Display main menu\n- `.ping` - Check bot responsiveness\n- `.logo` - Send bot logo\n- `.alive` - Check if bot is alive\n\n**Group Management**:\n- `.groupmenu` - Group-specific commands menu\n- `.mute` / `.unmute` - Mute/unmute group\n- `.groupinfo` - Display group information\n- `.tagall` - Tag all group members\n- `.hidetag` - Hidden tag message\n- `.kick`, `.add`, `.promote`, `.demote`, `.ban`, `.unban` - Member management\n\n**Moderation**:\n- `.warn @user` - Warn a user\n- `.warnings @user` - Check user warnings\n- Auto anti-link detection\n\n**Fun & Games**:\n- `.truth`, `.dare`, `.trivia`, `.guess`, `.tictactoe`, `.spam`, `.banbug`\n\n**Downloads**:\n- `.play`, `.song`, `.video`, `.ytmp4`, `.tiktok`, `.instagram`, `.facebook`\n\n**AI Features**:\n- `.gpt`, `.cyberai`, `.gemini`, `.calculator`, `.imagine`\n\n## Running the Bot\n\n### Development Mode\n```bash\nnpm run dev\n```\nUses nodemon for auto-reload on file changes.\n\n### Production Mode\n```bash\nnpm start\n```\nRuns the bot using standard Node.js.\n\n## Configuration\n\nBot settings are in `config.js`:\n- `botName`: Display name of the bot\n- `ownerName`: Owner's name\n- `version`: Bot version\n- `sessionFile`: Session credentials file path\n- `image`: Bot logo image path\n\n## Important Notes\n\n- **Session Data**: The `auth_info/` folder contains sensitive WhatsApp authentication data and is gitignored\n- **Auto-Reconnect**: The bot automatically reconnects if the connection drops\n- **Group Events**: Automatically sends welcome/goodbye messages when members join/leave\n- **Console Logging**: All incoming messages are logged with chalk-styled output\n\n## User Preferences\nNone configured yet.\n\n## Recent Changes\n- **2025-10-07**: Initial import and Replit environment setup\n  - Configured Node.js 20 environment\n  - Installed all dependencies\n  - Set up workflow for console output\n  - Created project documentation\n","size_bytes":4440},"commands/aiSearch.js":{"content":"/**\n * AI & Search Handler — Saitama MD\n * Commands: .gpt, .cyberai, .gemini, .calculator, .imagine\n */\n\nexport default async function aiSearch(sock, msg) {\n  const text = msg.message?.conversation || '';\n  const from = msg.key.remoteJid;\n  const lower = text.toLowerCase();\n\n  const sendReply = async (reply) => {\n    await sock.sendMessage(from, { text: reply });\n  };\n\n  if (lower.startsWith('.gpt') || lower.startsWith('.cyberai')) {\n    const query = text.replace(/^\\.(gpt|cyberai)\\s*/i, '');\n    await sendReply(`🤖 *Saitama GPT:* \"${query || 'Hello!'}\" \\n> (AI response coming soon...)`);\n  } \n  else if (lower.startsWith('.gemini')) {\n    const query = text.replace('.gemini', '').trim();\n    await sendReply(`💭 *Gemini:* Thinking about \"${query || 'your prompt'}\"... (Coming soon ⚡)`);\n  } \n  else if (lower.startsWith('.calculator')) {\n    const expr = text.replace('.calculator', '').trim();\n    try {\n      const result = eval(expr); // ⚠️ Basic evaluation — replace later for safety\n      await sendReply(`🧮 *Result:* ${expr} = ${result}`);\n    } catch {\n      await sendReply('⚠️ Invalid expression. Try `.calculator 5 + 3 * 2`');\n    }\n  } \n  else if (lower.startsWith('.imagine')) {\n    const prompt = text.replace('.imagine', '').trim();\n    await sendReply(`🌠 *Generating image for:* \"${prompt || 'your imagination'}\"... (Coming soon 🖼️)`);\n  }\n}\n","size_bytes":1395},"commands/alive.js":{"content":"import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport config from '../config.js';\nimport chalk from 'chalk';\nimport { getModeStatus } from './botmode.js';\n\n// 🕓 Format uptime nicely\nfunction formatUptime(seconds) {\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor((seconds % 3600) / 60);\n  const secs = Math.floor(seconds % 60);\n  return `${hrs}h ${mins}m ${secs}s`;\n}\n\nexport default async function alive(sock, remoteJid) {\n  const runtime = formatUptime(process.uptime());\n  const logoPath = path.resolve(config.image);\n  const modeStatus = getModeStatus();\n\n  if (!fs.existsSync(logoPath)) {\n    console.log(chalk.red('⚠️ Logo not found at ' + logoPath));\n  }\n\n  const frames = [\n    '⚡💪 *Powering up...*',\n    '⚡💥 *Systems online...*',\n    '⚡🔥 *FULLY OPERATIONAL!*',\n  ];\n\n  for (let i = 0; i < frames.length; i++) {\n    await sock.sendMessage(remoteJid, {\n      image: fs.existsSync(logoPath) ? { url: logoPath } : undefined,\n      caption: `╭━━━〔 👊 *ＳＡＩＴＡＭＡ  𝗠𝗗* 👊 〕━━━╮\n┃ ⚙️ *Version:* ${config.version}\n┃ ⏰ *Uptime:* ${runtime}\n┃ 👑 *Owner:* ${config.ownerName}\n┃ 🌍 *Platform:* ${os.platform().toUpperCase()}\n┃ 📊 *Mode:* ${modeStatus}\n╰━━━━━━━━━━━━━━━━━━━━╯\n\n${frames[i]}\n\n_\"I'm just a bot for fun...\"_ 💪\n> Type *.menu* to see available commands`\n    });\n    await new Promise(r => setTimeout(r, 400)); // animation effect\n  }\n}\n","size_bytes":1515},"commands/antilink.js":{"content":"export default async function antiLink(sock, msg) {\n  const from = msg.key.remoteJid;\n  const text = msg.message.conversation || msg.message.extendedTextMessage?.text || '';\n  \n  const linkRegex = /(https?:\\/\\/)?(www\\.)?(discord\\.gg|chat\\.whatsapp|tiktok\\.com|instagram\\.com)/gi;\n\n  if (linkRegex.test(text)) {\n    try {\n      await sock.sendMessage(from, { text: '🚫 Links are not allowed in this group!' });\n      await sock.groupParticipantsUpdate(from, [msg.key.participant], 'remove');\n    } catch (err) {\n      await sock.sendMessage(from, { text: `❌ Failed to remove user: ${err.message}` });\n    }\n  }\n}\n\n","size_bytes":617},"commands/downloads.js":{"content":"/**\n * Downloads Handler — Saitama MD\n * Commands: .play, .song, .video, .ytmp4, .tiktok, .instagram, .facebook\n */\n\nexport default async function downloads(sock, msg) {\n  const text = msg.message?.conversation?.toLowerCase() || '';\n  const from = msg.key.remoteJid;\n\n  const sendReply = async (reply) => {\n    await sock.sendMessage(from, { text: reply });\n  };\n\n  if (text.startsWith('.play') || text.startsWith('.song')) {\n    await sendReply('🎵 *Downloading your song...* (Feature coming soon 🎧)');\n  } \n  else if (text.startsWith('.video') || text.startsWith('.ytmp4')) {\n    await sendReply('🎥 *Downloading video from YouTube...* (Feature coming soon 📽️)');\n  } \n  else if (text.startsWith('.tiktok')) {\n    await sendReply('🌀 *Fetching TikTok video...* (Feature coming soon 🪩)');\n  } \n  else if (text.startsWith('.instagram')) {\n    await sendReply('📸 *Downloading Instagram media...* (Feature coming soon 💫)');\n  } \n  else if (text.startsWith('.facebook')) {\n    await sendReply('🌐 *Downloading Facebook video...* (Feature coming soon 🌍)');\n  }\n}\n","size_bytes":1089},"commands/funGames.js":{"content":"\n\nexport default async function funGames(sock, msg) {\n  const text = msg.message?.conversation || msg.message?.extendedTextMessage?.text || '';\n  const from = msg.key.remoteJid;\n  const command = text.toLowerCase().split(' ')[0];\n\n  if (command === \".spam\") {\n    const victim = text.split(\" \")[1] || \"chat\";\n    await sock.sendMessage(from, { text: `⚠️ Initiating Spam Bug on ${victim}...` });\n    const fakeSpam = [\n      \"💥 Injecting packets...\",\n      \"📡 Sending overload data...\",\n      \"⚙️ Bypassing anti-spam filter...\",\n      \"🔥 Flood sequence initiated!\",\n      \"💣 WhatsApp servers shaking...\",\n      \"✅ Spam bug completed successfully (fake 😎)\",\n    ];\n    for (const line of fakeSpam) {\n      await new Promise((r) => setTimeout(r, 700));\n      await sock.sendMessage(from, { text: line });\n    }\n    return;\n  }\n\n  // === BAN BUG (Fake Ban Attack) ===\n  if (command === \".banbug\") {\n    const target = text.split(\" \")[1] || \"unknown user\";\n    const stages = [\n      `🚫 Starting Ban Bug on *${target}*...`,\n      \"⚡ Connecting to Meta API...\",\n      \"📤 Uploading malicious payload...\",\n      \"🧩 Encrypting ban packet...\",\n      \"☠️ Sending to target...\",\n      \"💀 User permanently banned (jk 🤣)\",\n    ];\n    for (const stage of stages) {\n      await sock.sendMessage(from, { text: stage });\n      await new Promise((r) => setTimeout(r, 800));\n    }\n    await sock.sendMessage(from, { text: \"✅ Ban bug completed. (No one was harmed 😅)\" });\n    return;\n  }\n\n  // === Truth / Dare ===\n  const truths = [\n    \"What's your biggest fear?\",\n    \"Have you ever lied to your best friend?\",\n    \"What's the most embarrassing thing you've done?\"\n  ];\n\n  const dares = [\n    \"Send a funny selfie in the group.\",\n    \"Change your profile picture to a random emoji.\",\n    \"Say 'I love Saitama MD!' in the group.\"\n  ];\n\n  if (text === '.truth') {\n    const randomTruth = truths[Math.floor(Math.random() * truths.length)];\n    await sock.sendMessage(from, { text: `📝 Truth: ${randomTruth}` });\n    return;\n  }\n\n  if (text === '.dare') {\n    const randomDare = dares[Math.floor(Math.random() * dares.length)];\n    await sock.sendMessage(from, { text: `🎯 Dare: ${randomDare}` });\n    return;\n  }\n\n  // === Trivia ===\n  const triviaQs = [\n    { q: \"What is the capital of France?\", a: \"Paris\" },\n    { q: \"Which planet is known as the Red Planet?\", a: \"Mars\" },\n    { q: \"What year did the Titanic sink?\", a: \"1912\" }\n  ];\n\n  if (text === '.trivia') {\n    const randomTrivia = triviaQs[Math.floor(Math.random() * triviaQs.length)];\n    await sock.sendMessage(from, { text: `❓ Trivia: ${randomTrivia.q}\\n*(Answer: ${randomTrivia.a})*` });\n    return;\n  }\n\n  // === Guess (simple example) ===\n  const guesses = [\n    \"I am a superhero who codes hard. Who am I?\",\n    \"I have a big punch but stay silent. Who am I?\"\n  ];\n\n  if (text === '.guess') {\n    const randomGuess = guesses[Math.floor(Math.random() * guesses.length)];\n    await sock.sendMessage(from, { text: `🤔 Guess: ${randomGuess}` });\n    return;\n  }\n\n  // === TicTacToe placeholder ===\n  if (text === '.tictactoe') {\n    await sock.sendMessage(from, { text: \"🎮 TicTacToe: Coming soon! Use reactions to play.\" });\n    return;\n  }\n}\n","size_bytes":3249},"commands/group.js":{"content":"import chalk from \"chalk\";\n\nexport const groupMenu = async (sock, jid, uptime) => {\n  const groupText = `\n╭━━━〔 *👥 SAITAMA MD — GROUP MENU* 〕━━━╮\n┃ ⚡ *Uptime:* ${uptime}\n┃\n┃ 🛠️ *.add* _<number>_\n┃ ┣➤ Add a member to the group\n┃\n┃ 🚫 *.kick* _<@tag>_\n┃ ┣➤ Remove a user from the group\n┃\n┃ 📢 *.tagall*\n┃ ┣➤ Tag every member\n┃\n┃ 🧾 *.groupinfo*\n┃ ┣➤ Get group info & metadata\n┃\n┃ 🔒 *.mute / .unmute*\n┃ ┣➤ Enable or disable group chat\n┃\n┃ 🧹 *.clear*\n┃ ┗➤ Delete all messages\n╰━━━━━━━━━━━━━━━━━━━━━━╯\n`;\n\n  await sock.sendMessage(jid, { text: groupText });\n  console.log(chalk.cyan(\"[Saitama MD] Group menu sent ✅\"));\n};\n","size_bytes":773},"commands/groupinfo.js":{"content":"export default async function groupInfo(sock, msg) {\n  const from = msg.key.remoteJid;\n\n  try {\n    const metadata = await sock.groupMetadata(from);\n    const owner = metadata.owner || 'Unknown';\n    const participants = metadata.participants.map(p => p.id.split('@')[0]).join(', ');\n\n    await sock.sendMessage(from, {\n      text: `📋 *Group Info*\\n\\n👥 Name: ${metadata.subject}\\n🆔 ID: ${metadata.id}\\n👑 Owner: ${owner}\\n🧍‍♂️ Participants: ${participants}`,\n    });\n  } catch (err) {\n    await sock.sendMessage(from, { text: `❌ Could not fetch group info: ${err.message}` });\n  }\n}\n","size_bytes":605},"commands/help.js":{"content":"","size_bytes":0},"commands/hidetag.js":{"content":"export default async function hideTag(sock, msg) {\n  const from = msg.key.remoteJid;\n  try {\n    const metadata = await sock.groupMetadata(from);\n    const mentions = metadata.participants.map(p => p.id);\n    await sock.sendMessage(from, { text: '📢 Attention everyone!', mentions });\n  } catch (err) {\n    await sock.sendMessage(from, { text: `❌ Failed to hidetag: ${err.message}` });\n  }\n}\n","size_bytes":396},"commands/logo.js":{"content":"import fs from 'fs';\nimport path from 'path';\n\nexport default async function sendLogo(sock, from) {\n  const imagePath = path.join('assets', 'media', 'logo.jpg');\n\n  if (!fs.existsSync(imagePath)) {\n    await sock.sendMessage(from, { text: '⚠️ Logo not found!' });\n    return;\n  }\n\n  await sock.sendMessage(from, {\n    image: { url: imagePath },\n    caption: '📸 Here is the Saitama Logo!',\n  });\n}\n","size_bytes":404},"commands/manageMembers.js":{"content":"export default async function manageMembers(sock, msg) {\n  const from = msg.key.remoteJid;\n  const isGroup = from.endsWith('@g.us');\n  if (!isGroup) return;\n\n  const text = msg.message.conversation || msg.message.extendedTextMessage?.text;\n  const args = text.split(' ');\n\n  const command = args[0].toLowerCase();\n  const mentioned = msg.message.extendedTextMessage?.contextInfo?.mentionedJid;\n\n  if (!mentioned || mentioned.length === 0) {\n    await sock.sendMessage(from, { text: '❌ Please mention the user(s).' });\n    return;\n  }\n\n  try {\n    switch (command) {\n      case '.kick':\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'remove');\n        await sock.sendMessage(from, { text: '✅ User(s) kicked!' });\n        break;\n\n      case '.add':\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'add');\n        await sock.sendMessage(from, { text: '✅ User(s) added!' });\n        break;\n\n      case '.promote':\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'promote');\n        await sock.sendMessage(from, { text: '✅ User(s) promoted!' });\n        break;\n\n      case '.demote':\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'demote');\n        await sock.sendMessage(from, { text: '✅ User(s) demoted!' });\n        break;\n\n      case '.ban':\n        // Ban can be implemented via kick and tracking banned users\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'remove');\n        await sock.sendMessage(from, { text: '⛔ User(s) banned!' });\n        break;\n\n      case '.unban':\n        // Unban is similar to .add\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'add');\n        await sock.sendMessage(from, { text: '✅ User(s) unbanned!' });\n        break;\n    }\n  } catch (err) {\n    await sock.sendMessage(from, { text: `❌ Error: ${err.message}` });\n  }\n}\n","size_bytes":1996},"commands/menu.js":{"content":"import fs from \"fs\";\nimport path from \"path\";\nimport os from \"os\";\nimport config from \"../config.js\";\nimport { getModeStatus, isOwner } from \"./botmode.js\";\n\n// 🕓 Format uptime nicely\nfunction formatUptime(seconds) {\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor((seconds % 3600) / 60);\n  const secs = Math.floor(seconds % 60);\n  return `${hrs}h ${mins}m ${secs}s`;\n}\n\n// 🧠 Main Menu + Group Menu Combined\nexport default async function menu(sock, remoteJid, type = \"main\", msg = null) {\n  const runtime = formatUptime(process.uptime());\n  const menuImage = path.resolve(config.image);\n  const modeStatus = getModeStatus();\n  \n  // Check if user is owner to show owner-only commands\n  const userJid = msg?.key?.participant || msg?.key?.remoteJid || remoteJid;\n  const showOwnerCommands = isOwner(userJid);\n\n  // 💬 Menu Templates\n  const ownerSection = showOwnerCommands ? `\n┏━━━〔 👑 𝗢𝗪𝗡𝗘𝗥 𝗖𝗢𝗡𝗧𝗥𝗢𝗟𝗦 〕━━━┓\n┣➤ 🔒 .private — Enable private mode\n┣➤ 🌐 .public — Enable public mode\n┣➤ 🛡️ .sudo @user — Add sudo user\n┣➤ 🟢 .alwaysonline / .online\n┣➤ ⌨️ .autotyping / .typing\n┗━━━━━━━━━━━━━━━━━━┛\n` : '';\n\n  const menus = {\n    main: `\n╭━━━〔 👊 *ＳＡＩＴＡＭＡ  𝗠𝗗* 👊 〕━━━╮\n┃ ⚙️ *Version:* ${config.version}\n┃ ⏰ *Uptime:* ${runtime}\n┃ 👑 *Owner:* ${config.ownerName}\n┃ 🌍 *Platform:* ${os.platform().toUpperCase()}\n┃ 📊 *Mode:* ${modeStatus}\n╰━━━━━━━━━━━━━━━━━━━━╯\n\n┏━━━〔 🧠 𝗚𝗘𝗡𝗘𝗥𝗔𝗟 𝗠𝗘𝗡𝗨 〕━━━┓\n┣➤ 💬 .menu\n┣➤ ⚡ .alive\n┣➤ 🏓 .ping\n┣➤ 🖼️ .logo\n┗━━━━━━━━━━━━━━━━━━┛\n\n${ownerSection}\n\n┏━━━〔 👥 𝗚𝗥𝗢𝗨𝗣 𝗠𝗘𝗡𝗨 〕━━━┓\n┣➤ 🧑‍🤝‍🧑 .groupmenu\n┣➤ 🚫 .ban / .unban\n┣➤ 🪄 .promote / .demote\n┣➤ 🔇 .mute / .unmute\n┣➤ 🧩 .tagall / .hidetag\n┣➤ ⚔️ .kick\n┣➤ 🌐 .antilink\n┣➤ 💬 .welcome / .goodbye\n┗━━━━━━━━━━━━━━━━━━┛\n\n┏━━━〔 🪄 𝗙𝗨𝗡 & 𝗚𝗔𝗠𝗘𝗦 〕━━━┓\n┣➤ 🎲 .truth / .dare\n┣➤ ❓ .trivia\n┣➤ 🧩 .guess\n┣➤ 🕹️ .tictactoe\n┗━━━━━━━━━━━━━━━━━━┛\n\n┏━━━〔 🧭 𝗗𝗢𝗪𝗡𝗟𝗢𝗔𝗗𝗦 〕━━━┓\n┣➤ 🎵 .play / .song\n┣➤ 🎥 .video / .ytmp4\n┣➤ 🌀 .tiktok / .instagram / .facebook\n┗━━━━━━━━━━━━━━━━━━┛\n\n┏━━━〔 🔮 𝗔𝗜 & 𝗦𝗘𝗔𝗥𝗖𝗛 〕━━━┓\n┣➤ 🤖 .gpt / .cyberai\n┣➤ 💭 .gemini\n┣➤ 🧮 .calculator\n┣➤ 🌠 .imagine\n┗━━━━━━━━━━━━━━━━━━┛\n\n> *「 Saitama MD — The Hero Who Coded Too Hard 」*\n`,\n\n    group: `\n╭━━━〔 👥 *ＳＡＩＴＡＭＡ  𝗠𝗗 — 𝗚𝗥𝗢𝗨𝗣 𝗠𝗘𝗡𝗨* 👥 〕━━━╮\n┃ ⚙️ *Version:* ${config.version}\n┃ ⏰ *Uptime:* ${runtime}\n┃ 👑 *Owner:* ${config.ownerName}\n┃ 🌍 *Platform:* ${os.platform().toUpperCase()}\n┃ 📊 *Mode:* ${modeStatus}\n╰━━━━━━━━━━━━━━━━━━━━╯\n\n┏━━━〔 🧑‍🤝‍🧑 𝗚𝗥𝗢𝗨𝗣 𝗠𝗔𝗡𝗔𝗚𝗘𝗠𝗘𝗡𝗧 〕━━━┓\n┣➤ 🚫 .ban / .unban — Ban or unban users\n┣➤ 🪄 .promote / .demote — Manage admin roles\n┣➤ 🔇 .mute / .unmute — Control group chat\n┣➤ 🧩 .tagall / .hidetag — Mention all members\n┣➤ ⚔️ .kick — Remove member\n┣➤ 🌐 .antilink — Block links automatically\n┣➤ 💬 .welcome / .goodbye — Custom greetings\n┗━━━━━━━━━━━━━━━━━━┛\n\n> *「 Saitama MD — The Hero Who Coded Too Hard 」*\n`,\n  };\n\n  const selectedMenu = type === \"group\" ? menus.group : menus.main;\n\n  await sock.sendMessage(remoteJid, {\n    image: { url: menuImage },\n    caption: selectedMenu,\n  });\n}\n","size_bytes":4136},"commands/mute.js":{"content":"export default async function muteGroup(sock, msg) {\n  const from = msg.key.remoteJid;\n  const isGroup = from.endsWith('@g.us');\n  \n  if (!isGroup) {\n    await sock.sendMessage(from, { text: '❌ This command only works in groups!' });\n    return;\n  }\n\n  const text = msg.message.conversation || msg.message.extendedTextMessage?.text || '';\n  const command = text.toLowerCase();\n\n  try {\n    if (command === '.mute') {\n      // Mute group - only admins can send messages\n      await sock.groupSettingUpdate(from, 'announcement');\n      await sock.sendMessage(from, { text: '🔇 *Group Muted!*\\n\\nOnly admins can send messages now.' });\n    } else if (command === '.unmute') {\n      // Unmute group - everyone can send messages\n      await sock.groupSettingUpdate(from, 'not_announcement');\n      await sock.sendMessage(from, { text: '🔊 *Group Unmuted!*\\n\\nEveryone can send messages now.' });\n    }\n  } catch (err) {\n    await sock.sendMessage(from, { text: `❌ Error: ${err.message}\\n\\nMake sure the bot is an admin!` });\n  }\n}\n","size_bytes":1034},"commands/ping.js":{"content":"export default {\n  name: \"ping\",\n  description: \"Replies with Pong and latency\",\n  async execute(sock, msg) {\n    const start = Date.now();\n    await sock.sendMessage(msg.key.remoteJid, { text: \"Pong 🏓\" });\n    const delta = Date.now() - start;\n    // You can edit to calculate better latency; this gives a quick number.\n    await sock.sendMessage(msg.key.remoteJid, { text: `Latency: ${delta} ms` });\n  }\n};\n","size_bytes":412},"commands/sticker.js":{"content":"","size_bytes":0},"commands/tagall.js":{"content":"export default async function tagAll(sock, msg) {\n  const from = msg.key.remoteJid;\n  const isGroup = from.endsWith('@g.us');\n  \n  if (!isGroup) {\n    await sock.sendMessage(from, { text: '❌ This command only works in groups!' });\n    return;\n  }\n\n  try {\n    const metadata = await sock.groupMetadata(from);\n    const participants = metadata.participants;\n    const mentions = participants.map(p => p.id);\n    \n    // Build message with all mentions\n    let message = '📢 *Tagging All Group Members* 📢\\n\\n';\n    participants.forEach((participant, index) => {\n      message += `${index + 1}. @${participant.id.split('@')[0]}\\n`;\n    });\n    \n    await sock.sendMessage(from, { \n      text: message, \n      mentions: mentions \n    });\n  } catch (err) {\n    await sock.sendMessage(from, { text: `❌ Failed to tag all members: ${err.message}` });\n  }\n}\n","size_bytes":858},"commands/warnings.js":{"content":"import fs from 'fs';\nimport path from 'path';\n\nconst dataDir = 'data';\nconst warningsFile = path.join(dataDir, 'warnings.json');\n\n// Ensure data directory and warnings storage exist\nif (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });\nif (!fs.existsSync(warningsFile)) fs.writeFileSync(warningsFile, JSON.stringify({}));\n\nexport async function warnUser(sock, msg) {\n  const from = msg.key.remoteJid;\n  const mentioned = msg.message.extendedTextMessage?.contextInfo?.mentionedJid;\n  if (!mentioned || mentioned.length === 0) return await sock.sendMessage(from, { text: '❌ Mention a user to warn!' });\n\n  const data = JSON.parse(fs.readFileSync(warningsFile, 'utf8'));\n\n  for (let user of mentioned) {\n    if (!data[from]) data[from] = {};\n    if (!data[from][user]) data[from][user] = 0;\n    data[from][user] += 1;\n\n    await sock.sendMessage(from, { text: `⚠️ <@${user.split('@')[0]}> has been warned! Total warnings: ${data[from][user]}` });\n  }\n\n  fs.writeFileSync(warningsFile, JSON.stringify(data, null, 2));\n}\n\nexport async function checkWarnings(sock, msg) {\n  const from = msg.key.remoteJid;\n  const mentioned = msg.message.extendedTextMessage?.contextInfo?.mentionedJid;\n  const data = JSON.parse(fs.readFileSync(warningsFile, 'utf8'));\n\n  if (!mentioned || mentioned.length === 0) {\n    return await sock.sendMessage(from, { text: '❌ Mention a user to check warnings!' });\n  }\n\n  for (let user of mentioned) {\n    const count = data[from]?.[user] || 0;\n    await sock.sendMessage(from, { text: `⚠️ <@${user.split('@')[0]}> has ${count} warning(s)` });\n  }\n}\n","size_bytes":1599},"commands/welcome.js":{"content":"import fs from 'fs';\nconst welcomeFile = 'data/welcome.json';\n\nif (!fs.existsSync(welcomeFile)) fs.writeFileSync(welcomeFile, JSON.stringify({}));\n\nexport async function welcomeMessage(sock, participant) {\n  const from = participant.id.split('-')[0] + '@g.us';\n  const data = JSON.parse(fs.readFileSync(welcomeFile, 'utf8'));\n  const customMsg = data[from]?.welcome || '👋 Welcome to the group!';\n  \n  await sock.sendMessage(from, { text: `${customMsg}\\n@${participant.id.split('@')[0]}`, mentions: [participant.id] });\n}\n\nexport async function goodbyeMessage(sock, participant) {\n  const from = participant.id.split('-')[0] + '@g.us';\n  const data = JSON.parse(fs.readFileSync(welcomeFile, 'utf8'));\n  const customMsg = data[from]?.goodbye || '👋 Goodbye!';\n\n  await sock.sendMessage(from, { text: `${customMsg}\\n@${participant.id.split('@')[0]}`, mentions: [participant.id] });\n}\n","size_bytes":886},"utils/handler.js":{"content":"","size_bytes":0},"utils/logger.js":{"content":"","size_bytes":0},"commands/botmode.js":{"content":"import chalk from 'chalk';\nimport fs from 'fs';\nimport path from 'path';\n\nconst STATE_FILE = path.join('data', 'bot_state.json');\n\n// Load bot state\nfunction loadState() {\n  try {\n    if (fs.existsSync(STATE_FILE)) {\n      const data = fs.readFileSync(STATE_FILE, 'utf8');\n      return JSON.parse(data);\n    }\n  } catch (error) {\n    console.log(chalk.red('Error loading bot state:'), error.message);\n  }\n  return { privateMode: false, ownerJid: null, sudoUsers: [] };\n}\n\n// Save bot state\nfunction saveState(state) {\n  try {\n    fs.writeFileSync(STATE_FILE, JSON.stringify(state, null, 2), 'utf8');\n  } catch (error) {\n    console.log(chalk.red('Error saving bot state:'), error.message);\n  }\n}\n\n// Get normalized JID (remove device suffix)\nexport function getNormalizedJid(jid) {\n  if (!jid) return null;\n  return jid.split(':')[0];\n}\n\n// Check if user is owner\nexport function isOwner(userJid) {\n  const state = loadState();\n  if (!state.ownerJid) return false;\n  \n  const normalizedUser = getNormalizedJid(userJid);\n  const normalizedOwner = getNormalizedJid(state.ownerJid);\n  \n  // Also check if the user number matches the owner number (handle different JID formats)\n  const userNumber = normalizedUser.split('@')[0];\n  const ownerNumber = normalizedOwner.split('@')[0];\n  \n  return normalizedUser === normalizedOwner || userNumber === ownerNumber;\n}\n\n// Check if user is sudo\nexport function isSudo(userJid) {\n  const state = loadState();\n  const normalizedUser = getNormalizedJid(userJid);\n  return state.sudoUsers.some(sudo => getNormalizedJid(sudo) === normalizedUser);\n}\n\n// Check if user has access\nexport function hasAccess(userJid) {\n  const state = loadState();\n  if (!state.privateMode) return true; // Public mode - everyone has access\n  return isOwner(userJid) || isSudo(userJid);\n}\n\n// Initialize owner from socket\nexport function initializeOwner(sock) {\n  const state = loadState();\n  if (!state.ownerJid && sock.user && sock.user.id) {\n    state.ownerJid = getNormalizedJid(sock.user.id);\n    saveState(state);\n    console.log(chalk.green(`✅ Bot owner initialized: ${state.ownerJid}`));\n  }\n}\n\n// Set private mode\nexport async function setPrivateMode(sock, msg, enablePrivate) {\n  const from = msg.key.remoteJid;\n  const userJid = msg.key.participant || msg.key.remoteJid;\n  \n  if (!isOwner(userJid)) {\n    await sock.sendMessage(from, { \n      text: '⛔ *Access Denied*\\n\\n🔐 Only my supreme master can control my privacy settings.\\n\\n_You dare challenge the authority of Saitama?_ 💪' \n    });\n    return;\n  }\n  \n  const state = loadState();\n  state.privateMode = enablePrivate;\n  saveState(state);\n  \n  if (enablePrivate) {\n    await sock.sendMessage(from, { \n      text: '🔒 *PRIVATE MODE ACTIVATED*\\n\\n⚡ The bot is now in exclusive mode.\\n\\nOnly authorized users can use my commands.\\n\\n_The power is now restricted..._ 🛡️' \n    });\n  } else {\n    await sock.sendMessage(from, { \n      text: '🌐 *PUBLIC MODE ACTIVATED*\\n\\n⚡ The bot is now open to everyone.\\n\\nAll users can freely use my commands.\\n\\n_The power flows freely once more..._ ✨' \n    });\n  }\n}\n\n// Get access denied message\nexport function getAccessDeniedMessage() {\n  const messages = [\n    '⛔ *ACCESS DENIED*\\n\\n🔐 This bot is currently in *PRIVATE MODE*.\\n\\nOnly my supreme master has the authority to command me.\\n\\n_You shall not pass..._ ⚔️',\n    '⛔ *HALT!*\\n\\n🛡️ I serve only one master in private mode.\\n\\n_Your commands fall on deaf ears..._ 👊',\n    '⛔ *RESTRICTED ACCESS*\\n\\n⚡ The bot is locked for unauthorized users.\\n\\nMy master alone holds the key.\\n\\n_Know your place..._ 💥'\n  ];\n  return messages[Math.floor(Math.random() * messages.length)];\n}\n\n// Get current mode status\nexport function getModeStatus() {\n  const state = loadState();\n  return state.privateMode ? '🔒 Private Mode' : '🌐 Public Mode';\n}\n\n// Add sudo user\nexport async function addSudoUser(sock, msg) {\n  const from = msg.key.remoteJid;\n  const userJid = msg.key.participant || msg.key.remoteJid;\n  \n  if (!isOwner(userJid)) {\n    await sock.sendMessage(from, { \n      text: '⛔ *Access Denied*\\n\\nOnly the bot owner can add sudo users.' \n    });\n    return;\n  }\n  \n  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0];\n  if (!mentionedJid) {\n    await sock.sendMessage(from, { \n      text: '❌ Please mention a user to add as sudo.\\n\\n*Example:* .sudo @user' \n    });\n    return;\n  }\n  \n  const state = loadState();\n  const normalizedJid = getNormalizedJid(mentionedJid);\n  \n  if (state.sudoUsers.includes(normalizedJid)) {\n    await sock.sendMessage(from, { \n      text: '✅ User is already a sudo user.' \n    });\n    return;\n  }\n  \n  state.sudoUsers.push(normalizedJid);\n  saveState(state);\n  \n  await sock.sendMessage(from, { \n    text: `✅ *Sudo Access Granted*\\n\\n🔐 User has been elevated to sudo status.\\n\\nThey can now use commands even in private mode.` \n  });\n}\n","size_bytes":4939},"commands/presence.js":{"content":"// Store presence states\nlet alwaysOnline = false;  // Disabled\nlet autoTyping = false;    // Disabled\n\nexport async function toggleAlwaysOnline(sock, msg) {\n  const from = msg.key.remoteJid;\n  alwaysOnline = !alwaysOnline;\n  \n  if (alwaysOnline) {\n    await sock.sendMessage(from, { text: '✅ *Always Online Mode: ENABLED*\\n\\nBot will appear online at all times.' });\n  } else {\n    await sock.sendMessage(from, { text: '❌ *Always Online Mode: DISABLED*\\n\\nBot status will return to normal.' });\n  }\n}\n\nexport async function toggleAutoTyping(sock, msg) {\n  const from = msg.key.remoteJid;\n  autoTyping = !autoTyping;\n  \n  if (autoTyping) {\n    await sock.sendMessage(from, { text: '✅ *Auto Typing Mode: ENABLED*\\n\\nBot will show typing indicator on incoming messages.' });\n  } else {\n    await sock.sendMessage(from, { text: '❌ *Auto Typing Mode: DISABLED*\\n\\nTyping indicator will return to normal.' });\n  }\n}\n\nexport async function handlePresence(sock, from) {\n  // Send typing indicator if auto typing is enabled\n  if (autoTyping && from) {\n    try {\n      await sock.sendPresenceUpdate('composing', from);\n      // Stop typing after 3 seconds\n      setTimeout(async () => {\n        try {\n          await sock.sendPresenceUpdate('paused', from);\n        } catch (error) {\n          // Silently fail if connection is not ready\n        }\n      }, 3000);\n    } catch (error) {\n      // Silently fail if connection is not ready\n    }\n  }\n}\n\nexport async function maintainOnlineStatus(sock) {\n  if (alwaysOnline) {\n    try {\n      await sock.sendPresenceUpdate('available');\n    } catch (error) {\n      // Silently fail if connection is not ready\n      throw error; // Re-throw to be caught by interval handler\n    }\n  }\n}\n\nexport function getPresenceStatus() {\n  return { alwaysOnline, autoTyping };\n}\n","size_bytes":1809}},"version":1}