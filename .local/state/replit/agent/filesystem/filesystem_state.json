{"file_contents":{"config.js":{"content":"export default {\n  botName: \"Saitama Bot\",\n  ownerName: \"Lord Saitama\",\n  version: \"1.0.0\",\n  sessionFile: \"./session/creds.json\",\n  image: \"assets/media/logo.jpg\",\n};\n","size_bytes":168},"index.js":{"content":"import makeWASocket, { useMultiFileAuthState } from '@whiskeysockets/baileys';\nimport P from \"pino\";\nimport chalk from 'chalk';\nimport qrcode from 'qrcode-terminal';\nimport fs from 'fs';\nimport path from 'path';\nimport menu from \"./commands/menu.js\";\nimport alive from \"./commands/alive.js\";\nimport config from \"./config.js\";\nimport { groupMenu } from \"./commands/group.js\";\nimport muteGroup from \"./commands/mute.js\";\nimport manageMembers from \"./commands/manageMembers.js\";\nimport groupInfo from \"./commands/groupinfo.js\";\nimport tagAll from \"./commands/tagall.js\";\nimport sendLogo from './commands/logo.js';\nimport { warnUser, checkWarnings } from './commands/warnings.js';\nimport antiLink from './commands/antilink.js';\nimport hideTag from './commands/hidetag.js';\nimport { welcomeMessage, goodbyeMessage } from './commands/welcome.js';\nimport funGames from './commands/funGames.js';\nimport downloads from './commands/downloads.js';\nimport aiSearch from './commands/aiSearch.js';\nimport { toggleAlwaysOnline, toggleAutoTyping, handlePresence, maintainOnlineStatus } from './commands/presence.js';\nimport { initializeOwner, hasAccess, isOwner, getAccessDeniedMessage, setPrivateMode, addSudoUser, getModeStatus } from './commands/botmode.js';\n\n// === Bot Banner Display ===\nconst banner = `\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— \nâ–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘\nâ•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘\nâ•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•\n              Saitama Bot â€” Activated âš¡\n`;\n\nconsole.log(chalk.cyanBright(banner));\n\n// === Image Display ===\nconst imagePath = path.join('assets', 'media', 'logo.jpg');\nif (fs.existsSync(imagePath)) {\n  console.log(chalk.green('ğŸ“¸ Displaying Saitama Logo...'));\n  console.log(chalk.gray(`(Image path: ${imagePath})`));\n} else {\n  console.log(chalk.red('âš ï¸ Logo not found in assets/media/logo.jpg'));\n}\n\n// === Start WhatsApp Connection ===\nasync function startBot() {\n  const { state, saveCreds } = await useMultiFileAuthState('auth_info');\n\n  const sock = makeWASocket({\n    auth: state,\n    browser: ['Saitama Bot', 'Chrome', '1.0.0'],\n    logger: P({ level: 'silent' }),\n    syncFullHistory: false,\n    markOnlineOnConnect: true\n  });\n\n  sock.ev.on('creds.update', saveCreds);\n\n  // Connection updates\n  sock.ev.on('connection.update', async (update) => {\n    const { connection, lastDisconnect, qr } = update;\n\n    if (qr) {\n      console.log(chalk.yellow('\\nğŸ“Œ Scan this QR code with WhatsApp:\\n'));\n      qrcode.generate(qr, { small: true });\n      console.log(chalk.gray('\\nOr use this pairing code: ' + qr));\n    }\n\n    if (connection === 'open') {\n      console.log(chalk.greenBright('âœ… Saitama Bot Connected Successfully!'));\n      console.log(chalk.magentaBright('âš¡ Initializing owner...'));\n      initializeOwner(sock);\n      console.log(chalk.cyanBright(`ğŸ“Š Bot Mode: ${getModeStatus()}`));\n    } else if (connection === 'close') {\n      const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== 401;\n      if (shouldReconnect) {\n        console.log(chalk.yellow('âš ï¸ Connection closed, reconnecting...'));\n        setTimeout(() => startBot(), 3000); // reconnect after 3 seconds\n      } else {\n        console.log(chalk.red('âŒ Connection closed. Please delete auth_info and scan QR again.'));\n      }\n    }\n  });\n\n  // Welcome / Goodbye events\n  sock.ev.on('group-participants.update', async (update) => {\n    for (let participant of update.participants) {\n      if (update.action === 'add') await welcomeMessage(sock, { id: participant });\n      if (update.action === 'remove') await goodbyeMessage(sock, { id: participant });\n    }\n  });\n\n  // Handle incoming messages\n  sock.ev.on('messages.upsert', async (m) => {\n    try {\n      const msg = m.messages[0];\n      \n      if (!msg.message) return;\n      \n      // Ignore protocol messages, notifications, and status updates\n      if (msg.message.protocolMessage || msg.message.senderKeyDistributionMessage) return;\n      \n      const from = msg.key.remoteJid;\n      \n      // Debug: Log message info\n      console.log(chalk.magenta('ğŸ“¨ Message - fromMe:'), msg.key.fromMe, 'from:', from);\n    \n    // Extract text from various message types\n    const text = \n      msg.message.conversation || \n      msg.message.extendedTextMessage?.text || \n      msg.message.imageMessage?.caption || \n      msg.message.videoMessage?.caption || \n      '';\n\n    console.log(chalk.yellow(`[${from}] ${text}`));\n    \n    // Skip if no text\n    if (!text) {\n      console.log(chalk.red('âš ï¸ No text found in message'));\n      return;\n    }\n\n    // Check if message is a command\n    if (!text.startsWith('.')) return;\n    \n    // Get user JID for access control\n    const userJid = msg.key.participant || msg.key.remoteJid;\n    \n    // === ACCESS CONTROL MIDDLEWARE ===\n    // Allow these commands without restriction\n    const publicCommands = ['.menu', '.alive', '.ping'];\n    const ownerOnlyCommands = ['.private', '.public', '.sudo'];\n    \n    // Messages from the bot owner (fromMe) always have access\n    const isOwnerMessage = msg.key.fromMe || isOwner(userJid);\n    \n    // Check if user has access\n    if (!isOwnerMessage && !publicCommands.includes(text.toLowerCase().split(' ')[0])) {\n      if (!hasAccess(userJid)) {\n        await sock.sendMessage(from, { text: getAccessDeniedMessage() });\n        return;\n      }\n    }\n    \n    // Owner-only commands check\n    if (ownerOnlyCommands.includes(text.toLowerCase().split(' ')[0]) && !isOwnerMessage) {\n      await sock.sendMessage(from, { \n        text: 'â›” *Access Denied*\\n\\nğŸ” Only my supreme master can use this command.\\n\\n_Know your place..._ ğŸ’ª' \n      });\n      return;\n    }\n\n    // === Commands ===\n    switch (true) {\n      case text.toLowerCase() === '.menu':\n        await menu(sock, from, 'main', msg);\n        break;\n\n      case text.toLowerCase() === '.alive':\n        await alive(sock, from);\n        break;\n\n      case text.toLowerCase() === '.logo':\n        await sendLogo(sock, from);\n        break;\n\n      case text.toLowerCase() === '.groupmenu':\n        await menu(sock, from, 'group', msg);\n        break;\n\n      case text.toLowerCase() === '.ping':\n        const frames = ['ğŸ“', 'ğŸ“ğŸ“', 'ğŸ“ğŸ“ğŸ“', 'ğŸ“ğŸ“', 'ğŸ“', 'âœ… Pong! Saitama is active!'];\n        for (let i = 0; i < frames.length; i++) {\n          await sock.sendMessage(from, { text: frames[i] });\n          await new Promise(r => setTimeout(r, 300));\n        }\n        break;\n\n      case text.toLowerCase() === '.alwaysonline':\n      case text.toLowerCase() === '.online':\n        await toggleAlwaysOnline(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.autotyping':\n      case text.toLowerCase() === '.typing':\n        await toggleAutoTyping(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.private':\n        await setPrivateMode(sock, msg, true);\n        break;\n\n      case text.toLowerCase() === '.public':\n        await setPrivateMode(sock, msg, false);\n        break;\n\n      case text.toLowerCase().startsWith('.sudo'):\n        await addSudoUser(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.mute' || text.toLowerCase() === '.unmute':\n        await muteGroup(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.groupinfo':\n        await groupInfo(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.tagall':\n        await tagAll(sock, msg);\n        break;\n\n      case text.toLowerCase().startsWith('.warn'):\n        await warnUser(sock, msg);\n        break;\n\n      case text.toLowerCase().startsWith('.warnings'):\n        await checkWarnings(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.hidetag':\n        await hideTag(sock, msg);\n        break;\n\n      case ['.kick', '.add', '.promote', '.demote', '.ban', '.unban'].includes(text.toLowerCase().split(' ')[0]):\n        await manageMembers(sock, msg);\n        break;\n\n      case ['.truth', '.dare', '.trivia', '.guess', '.tictactoe'].includes(text.toLowerCase()):\n      case text.toLowerCase().startsWith('.spam'):\n      case text.toLowerCase().startsWith('.banbug'):\n        await funGames(sock, msg);\n        break;\n\n      case ['.play', '.song', '.video', '.ytmp4', '.tiktok', '.instagram', '.facebook'].some(cmd => text.toLowerCase().startsWith(cmd)):\n        await downloads(sock, msg);\n        break;\n\n      case ['.gpt', '.cyberai', '.gemini', '.calculator', '.imagine'].some(cmd => text.toLowerCase().startsWith(cmd)):\n        await aiSearch(sock, msg);\n        break;\n    }\n\n      // Anti-link detection\n      if (text.includes('https://') || text.includes('www.')) await antiLink(sock, msg);\n    } catch (error) {\n      console.log(chalk.red('Error handling message:'), error.message);\n    }\n  });\n}\n\nstartBot();\n","size_bytes":9504},"replit.md":{"content":"# Saitama Bot - WhatsApp Multi-Function Bot\n\n## Overview\nSaitama Bot is a multi-function WhatsApp bot built with Node.js and the Baileys library. The bot provides various commands for group management, games, downloads, AI interactions, and more.\n\n**Current State**: Configured and ready to run on Replit environment  \n**Last Updated**: October 7, 2025\n\n## Project Architecture\n\n### Technology Stack\n- **Runtime**: Node.js 20\n- **Main Library**: @whiskeysockets/baileys (WhatsApp Web API)\n- **Dependencies**: \n  - chalk (terminal styling)\n  - qrcode-terminal (QR code display)\n  - nodemon (development auto-reload)\n\n### Project Structure\n```\n.\nâ”œâ”€â”€ assets/\nâ”‚   â”œâ”€â”€ media/          # Bot logo and media files\nâ”‚   â””â”€â”€ menu/           # Menu text files\nâ”œâ”€â”€ commands/           # All bot command handlers\nâ”‚   â”œâ”€â”€ aiSearch.js     # AI-powered search commands\nâ”‚   â”œâ”€â”€ alive.js        # Alive check\nâ”‚   â”œâ”€â”€ antilink.js     # Anti-link protection\nâ”‚   â”œâ”€â”€ downloads.js    # Download commands (YouTube, TikTok, etc.)\nâ”‚   â”œâ”€â”€ funGames.js     # Fun game commands\nâ”‚   â”œâ”€â”€ group.js        # Group management commands\nâ”‚   â”œâ”€â”€ groupinfo.js    # Group information\nâ”‚   â”œâ”€â”€ help.js         # Help command\nâ”‚   â”œâ”€â”€ hidetag.js      # Hide tag command\nâ”‚   â”œâ”€â”€ logo.js         # Send logo command\nâ”‚   â”œâ”€â”€ manageMembers.js # Member management (kick, add, promote, etc.)\nâ”‚   â”œâ”€â”€ menu.js         # Main menu\nâ”‚   â”œâ”€â”€ mute.js         # Mute/unmute group\nâ”‚   â”œâ”€â”€ ping.js         # Ping command\nâ”‚   â”œâ”€â”€ sticker.js      # Sticker creation\nâ”‚   â”œâ”€â”€ tagall.js       # Tag all members\nâ”‚   â”œâ”€â”€ warnings.js     # Warning system\nâ”‚   â””â”€â”€ welcome.js      # Welcome/goodbye messages\nâ”œâ”€â”€ session/            # WhatsApp session data (gitignored)\nâ”œâ”€â”€ utils/              # Utility functions\nâ”‚   â”œâ”€â”€ handler.js      # Message handler utilities\nâ”‚   â””â”€â”€ logger.js       # Logging utilities\nâ”œâ”€â”€ config.js           # Bot configuration\nâ””â”€â”€ index.js            # Main entry point\n```\n\n## How It Works\n\n### Authentication\nThe bot uses WhatsApp Web's multi-device authentication. On first run:\n1. A QR code is displayed in the console\n2. Scan it with WhatsApp on your phone\n3. Session credentials are saved to `auth_info/` folder\n4. Subsequent runs auto-connect using saved credentials\n\n### Command System\nThe bot listens for messages and responds to commands starting with `.` (dot prefix):\n\n**General Commands**:\n- `.menu` - Display main menu\n- `.ping` - Check bot responsiveness\n- `.logo` - Send bot logo\n- `.alive` - Check if bot is alive\n\n**Group Management**:\n- `.groupmenu` - Group-specific commands menu\n- `.mute` / `.unmute` - Mute/unmute group\n- `.groupinfo` - Display group information\n- `.tagall` - Tag all group members\n- `.hidetag` - Hidden tag message\n- `.kick`, `.add`, `.promote`, `.demote`, `.ban`, `.unban` - Member management\n\n**Moderation**:\n- `.warn @user` - Warn a user\n- `.warnings @user` - Check user warnings\n- Auto anti-link detection\n\n**Fun & Games**:\n- `.truth`, `.dare`, `.trivia`, `.guess`, `.tictactoe`, `.spam`, `.banbug`\n\n**Downloads**:\n- `.play`, `.song`, `.video`, `.ytmp4`, `.tiktok`, `.instagram`, `.facebook`\n\n**AI Features**:\n- `.gpt`, `.cyberai`, `.gemini`, `.calculator`, `.imagine`\n\n## Running the Bot\n\n### Development Mode\n```bash\nnpm run dev\n```\nUses nodemon for auto-reload on file changes.\n\n### Production Mode\n```bash\nnpm start\n```\nRuns the bot using standard Node.js.\n\n## Configuration\n\nBot settings are in `config.js`:\n- `botName`: Display name of the bot\n- `ownerName`: Owner's name\n- `version`: Bot version\n- `sessionFile`: Session credentials file path\n- `image`: Bot logo image path\n\n## Important Notes\n\n- **Session Data**: The `auth_info/` folder contains sensitive WhatsApp authentication data and is gitignored\n- **Auto-Reconnect**: The bot automatically reconnects if the connection drops\n- **Group Events**: Automatically sends welcome/goodbye messages when members join/leave\n- **Console Logging**: All incoming messages are logged with chalk-styled output\n\n## User Preferences\nNone configured yet.\n\n## Recent Changes\n- **2025-10-07**: Initial import and Replit environment setup\n  - Configured Node.js 20 environment\n  - Installed all dependencies\n  - Set up workflow for console output\n  - Created project documentation\n","size_bytes":4440},"commands/aiSearch.js":{"content":"/**\n * AI & Search Handler â€” Saitama MD\n * Commands: .gpt, .cyberai, .gemini, .calculator, .imagine\n */\n\nexport default async function aiSearch(sock, msg) {\n  const text = msg.message?.conversation || '';\n  const from = msg.key.remoteJid;\n  const lower = text.toLowerCase();\n\n  const sendReply = async (reply) => {\n    await sock.sendMessage(from, { text: reply });\n  };\n\n  if (lower.startsWith('.gpt') || lower.startsWith('.cyberai')) {\n    const query = text.replace(/^\\.(gpt|cyberai)\\s*/i, '');\n    await sendReply(`ğŸ¤– *Saitama GPT:* \"${query || 'Hello!'}\" \\n> (AI response coming soon...)`);\n  } \n  else if (lower.startsWith('.gemini')) {\n    const query = text.replace('.gemini', '').trim();\n    await sendReply(`ğŸ’­ *Gemini:* Thinking about \"${query || 'your prompt'}\"... (Coming soon âš¡)`);\n  } \n  else if (lower.startsWith('.calculator')) {\n    const expr = text.replace('.calculator', '').trim();\n    try {\n      const result = eval(expr); // âš ï¸ Basic evaluation â€” replace later for safety\n      await sendReply(`ğŸ§® *Result:* ${expr} = ${result}`);\n    } catch {\n      await sendReply('âš ï¸ Invalid expression. Try `.calculator 5 + 3 * 2`');\n    }\n  } \n  else if (lower.startsWith('.imagine')) {\n    const prompt = text.replace('.imagine', '').trim();\n    await sendReply(`ğŸŒ  *Generating image for:* \"${prompt || 'your imagination'}\"... (Coming soon ğŸ–¼ï¸)`);\n  }\n}\n","size_bytes":1395},"commands/alive.js":{"content":"import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport config from '../config.js';\nimport chalk from 'chalk';\nimport { getModeStatus } from './botmode.js';\n\n// ğŸ•“ Format uptime nicely\nfunction formatUptime(seconds) {\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor((seconds % 3600) / 60);\n  const secs = Math.floor(seconds % 60);\n  return `${hrs}h ${mins}m ${secs}s`;\n}\n\nexport default async function alive(sock, remoteJid) {\n  const runtime = formatUptime(process.uptime());\n  const logoPath = path.resolve(config.image);\n  const modeStatus = getModeStatus();\n\n  if (!fs.existsSync(logoPath)) {\n    console.log(chalk.red('âš ï¸ Logo not found at ' + logoPath));\n  }\n\n  const frames = [\n    'âš¡ğŸ’ª *Powering up...*',\n    'âš¡ğŸ’¥ *Systems online...*',\n    'âš¡ğŸ”¥ *FULLY OPERATIONAL!*',\n  ];\n\n  for (let i = 0; i < frames.length; i++) {\n    await sock.sendMessage(remoteJid, {\n      image: fs.existsSync(logoPath) ? { url: logoPath } : undefined,\n      caption: `â•­â”â”â”ã€” ğŸ‘Š *ï¼³ï¼¡ï¼©ï¼´ï¼¡ï¼­ï¼¡  ğ— ğ——* ğŸ‘Š ã€•â”â”â”â•®\nâ”ƒ âš™ï¸ *Version:* ${config.version}\nâ”ƒ â° *Uptime:* ${runtime}\nâ”ƒ ğŸ‘‘ *Owner:* ${config.ownerName}\nâ”ƒ ğŸŒ *Platform:* ${os.platform().toUpperCase()}\nâ”ƒ ğŸ“Š *Mode:* ${modeStatus}\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•¯\n\n${frames[i]}\n\n_\"I'm just a bot for fun...\"_ ğŸ’ª\n> Type *.menu* to see available commands`\n    });\n    await new Promise(r => setTimeout(r, 400)); // animation effect\n  }\n}\n","size_bytes":1515},"commands/antilink.js":{"content":"export default async function antiLink(sock, msg) {\n  const from = msg.key.remoteJid;\n  const text = msg.message.conversation || msg.message.extendedTextMessage?.text || '';\n  \n  const linkRegex = /(https?:\\/\\/)?(www\\.)?(discord\\.gg|chat\\.whatsapp|tiktok\\.com|instagram\\.com)/gi;\n\n  if (linkRegex.test(text)) {\n    try {\n      await sock.sendMessage(from, { text: 'ğŸš« Links are not allowed in this group!' });\n      await sock.groupParticipantsUpdate(from, [msg.key.participant], 'remove');\n    } catch (err) {\n      await sock.sendMessage(from, { text: `âŒ Failed to remove user: ${err.message}` });\n    }\n  }\n}\n\n","size_bytes":617},"commands/downloads.js":{"content":"/**\n * Downloads Handler â€” Saitama MD\n * Commands: .play, .song, .video, .ytmp4, .tiktok, .instagram, .facebook\n */\n\nexport default async function downloads(sock, msg) {\n  const text = msg.message?.conversation?.toLowerCase() || '';\n  const from = msg.key.remoteJid;\n\n  const sendReply = async (reply) => {\n    await sock.sendMessage(from, { text: reply });\n  };\n\n  if (text.startsWith('.play') || text.startsWith('.song')) {\n    await sendReply('ğŸµ *Downloading your song...* (Feature coming soon ğŸ§)');\n  } \n  else if (text.startsWith('.video') || text.startsWith('.ytmp4')) {\n    await sendReply('ğŸ¥ *Downloading video from YouTube...* (Feature coming soon ğŸ“½ï¸)');\n  } \n  else if (text.startsWith('.tiktok')) {\n    await sendReply('ğŸŒ€ *Fetching TikTok video...* (Feature coming soon ğŸª©)');\n  } \n  else if (text.startsWith('.instagram')) {\n    await sendReply('ğŸ“¸ *Downloading Instagram media...* (Feature coming soon ğŸ’«)');\n  } \n  else if (text.startsWith('.facebook')) {\n    await sendReply('ğŸŒ *Downloading Facebook video...* (Feature coming soon ğŸŒ)');\n  }\n}\n","size_bytes":1089},"commands/funGames.js":{"content":"\n\nexport default async function funGames(sock, msg) {\n  const text = msg.message?.conversation || msg.message?.extendedTextMessage?.text || '';\n  const from = msg.key.remoteJid;\n  const command = text.toLowerCase().split(' ')[0];\n\n  if (command === \".spam\") {\n    const victim = text.split(\" \")[1] || \"chat\";\n    await sock.sendMessage(from, { text: `âš ï¸ Initiating Spam Bug on ${victim}...` });\n    const fakeSpam = [\n      \"ğŸ’¥ Injecting packets...\",\n      \"ğŸ“¡ Sending overload data...\",\n      \"âš™ï¸ Bypassing anti-spam filter...\",\n      \"ğŸ”¥ Flood sequence initiated!\",\n      \"ğŸ’£ WhatsApp servers shaking...\",\n      \"âœ… Spam bug completed successfully (fake ğŸ˜)\",\n    ];\n    for (const line of fakeSpam) {\n      await new Promise((r) => setTimeout(r, 700));\n      await sock.sendMessage(from, { text: line });\n    }\n    return;\n  }\n\n  // === BAN BUG (Fake Ban Attack) ===\n  if (command === \".banbug\") {\n    const target = text.split(\" \")[1] || \"unknown user\";\n    const stages = [\n      `ğŸš« Starting Ban Bug on *${target}*...`,\n      \"âš¡ Connecting to Meta API...\",\n      \"ğŸ“¤ Uploading malicious payload...\",\n      \"ğŸ§© Encrypting ban packet...\",\n      \"â˜ ï¸ Sending to target...\",\n      \"ğŸ’€ User permanently banned (jk ğŸ¤£)\",\n    ];\n    for (const stage of stages) {\n      await sock.sendMessage(from, { text: stage });\n      await new Promise((r) => setTimeout(r, 800));\n    }\n    await sock.sendMessage(from, { text: \"âœ… Ban bug completed. (No one was harmed ğŸ˜…)\" });\n    return;\n  }\n\n  // === Truth / Dare ===\n  const truths = [\n    \"What's your biggest fear?\",\n    \"Have you ever lied to your best friend?\",\n    \"What's the most embarrassing thing you've done?\"\n  ];\n\n  const dares = [\n    \"Send a funny selfie in the group.\",\n    \"Change your profile picture to a random emoji.\",\n    \"Say 'I love Saitama MD!' in the group.\"\n  ];\n\n  if (text === '.truth') {\n    const randomTruth = truths[Math.floor(Math.random() * truths.length)];\n    await sock.sendMessage(from, { text: `ğŸ“ Truth: ${randomTruth}` });\n    return;\n  }\n\n  if (text === '.dare') {\n    const randomDare = dares[Math.floor(Math.random() * dares.length)];\n    await sock.sendMessage(from, { text: `ğŸ¯ Dare: ${randomDare}` });\n    return;\n  }\n\n  // === Trivia ===\n  const triviaQs = [\n    { q: \"What is the capital of France?\", a: \"Paris\" },\n    { q: \"Which planet is known as the Red Planet?\", a: \"Mars\" },\n    { q: \"What year did the Titanic sink?\", a: \"1912\" }\n  ];\n\n  if (text === '.trivia') {\n    const randomTrivia = triviaQs[Math.floor(Math.random() * triviaQs.length)];\n    await sock.sendMessage(from, { text: `â“ Trivia: ${randomTrivia.q}\\n*(Answer: ${randomTrivia.a})*` });\n    return;\n  }\n\n  // === Guess (simple example) ===\n  const guesses = [\n    \"I am a superhero who codes hard. Who am I?\",\n    \"I have a big punch but stay silent. Who am I?\"\n  ];\n\n  if (text === '.guess') {\n    const randomGuess = guesses[Math.floor(Math.random() * guesses.length)];\n    await sock.sendMessage(from, { text: `ğŸ¤” Guess: ${randomGuess}` });\n    return;\n  }\n\n  // === TicTacToe placeholder ===\n  if (text === '.tictactoe') {\n    await sock.sendMessage(from, { text: \"ğŸ® TicTacToe: Coming soon! Use reactions to play.\" });\n    return;\n  }\n}\n","size_bytes":3249},"commands/group.js":{"content":"import chalk from \"chalk\";\n\nexport const groupMenu = async (sock, jid, uptime) => {\n  const groupText = `\nâ•­â”â”â”ã€” *ğŸ‘¥ SAITAMA MD â€” GROUP MENU* ã€•â”â”â”â•®\nâ”ƒ âš¡ *Uptime:* ${uptime}\nâ”ƒ\nâ”ƒ ğŸ› ï¸ *.add* _<number>_\nâ”ƒ â”£â¤ Add a member to the group\nâ”ƒ\nâ”ƒ ğŸš« *.kick* _<@tag>_\nâ”ƒ â”£â¤ Remove a user from the group\nâ”ƒ\nâ”ƒ ğŸ“¢ *.tagall*\nâ”ƒ â”£â¤ Tag every member\nâ”ƒ\nâ”ƒ ğŸ§¾ *.groupinfo*\nâ”ƒ â”£â¤ Get group info & metadata\nâ”ƒ\nâ”ƒ ğŸ”’ *.mute / .unmute*\nâ”ƒ â”£â¤ Enable or disable group chat\nâ”ƒ\nâ”ƒ ğŸ§¹ *.clear*\nâ”ƒ â”—â¤ Delete all messages\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•¯\n`;\n\n  await sock.sendMessage(jid, { text: groupText });\n  console.log(chalk.cyan(\"[Saitama MD] Group menu sent âœ…\"));\n};\n","size_bytes":773},"commands/groupinfo.js":{"content":"export default async function groupInfo(sock, msg) {\n  const from = msg.key.remoteJid;\n\n  try {\n    const metadata = await sock.groupMetadata(from);\n    const owner = metadata.owner || 'Unknown';\n    const participants = metadata.participants.map(p => p.id.split('@')[0]).join(', ');\n\n    await sock.sendMessage(from, {\n      text: `ğŸ“‹ *Group Info*\\n\\nğŸ‘¥ Name: ${metadata.subject}\\nğŸ†” ID: ${metadata.id}\\nğŸ‘‘ Owner: ${owner}\\nğŸ§â€â™‚ï¸ Participants: ${participants}`,\n    });\n  } catch (err) {\n    await sock.sendMessage(from, { text: `âŒ Could not fetch group info: ${err.message}` });\n  }\n}\n","size_bytes":605},"commands/help.js":{"content":"","size_bytes":0},"commands/hidetag.js":{"content":"export default async function hideTag(sock, msg) {\n  const from = msg.key.remoteJid;\n  try {\n    const metadata = await sock.groupMetadata(from);\n    const mentions = metadata.participants.map(p => p.id);\n    await sock.sendMessage(from, { text: 'ğŸ“¢ Attention everyone!', mentions });\n  } catch (err) {\n    await sock.sendMessage(from, { text: `âŒ Failed to hidetag: ${err.message}` });\n  }\n}\n","size_bytes":396},"commands/logo.js":{"content":"import fs from 'fs';\nimport path from 'path';\n\nexport default async function sendLogo(sock, from) {\n  const imagePath = path.join('assets', 'media', 'logo.jpg');\n\n  if (!fs.existsSync(imagePath)) {\n    await sock.sendMessage(from, { text: 'âš ï¸ Logo not found!' });\n    return;\n  }\n\n  await sock.sendMessage(from, {\n    image: { url: imagePath },\n    caption: 'ğŸ“¸ Here is the Saitama Logo!',\n  });\n}\n","size_bytes":404},"commands/manageMembers.js":{"content":"export default async function manageMembers(sock, msg) {\n  const from = msg.key.remoteJid;\n  const isGroup = from.endsWith('@g.us');\n  if (!isGroup) return;\n\n  const text = msg.message.conversation || msg.message.extendedTextMessage?.text;\n  const args = text.split(' ');\n\n  const command = args[0].toLowerCase();\n  const mentioned = msg.message.extendedTextMessage?.contextInfo?.mentionedJid;\n\n  if (!mentioned || mentioned.length === 0) {\n    await sock.sendMessage(from, { text: 'âŒ Please mention the user(s).' });\n    return;\n  }\n\n  try {\n    switch (command) {\n      case '.kick':\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'remove');\n        await sock.sendMessage(from, { text: 'âœ… User(s) kicked!' });\n        break;\n\n      case '.add':\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'add');\n        await sock.sendMessage(from, { text: 'âœ… User(s) added!' });\n        break;\n\n      case '.promote':\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'promote');\n        await sock.sendMessage(from, { text: 'âœ… User(s) promoted!' });\n        break;\n\n      case '.demote':\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'demote');\n        await sock.sendMessage(from, { text: 'âœ… User(s) demoted!' });\n        break;\n\n      case '.ban':\n        // Ban can be implemented via kick and tracking banned users\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'remove');\n        await sock.sendMessage(from, { text: 'â›” User(s) banned!' });\n        break;\n\n      case '.unban':\n        // Unban is similar to .add\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'add');\n        await sock.sendMessage(from, { text: 'âœ… User(s) unbanned!' });\n        break;\n    }\n  } catch (err) {\n    await sock.sendMessage(from, { text: `âŒ Error: ${err.message}` });\n  }\n}\n","size_bytes":1996},"commands/menu.js":{"content":"import fs from \"fs\";\nimport path from \"path\";\nimport os from \"os\";\nimport config from \"../config.js\";\nimport { getModeStatus, isOwner } from \"./botmode.js\";\n\n// ğŸ•“ Format uptime nicely\nfunction formatUptime(seconds) {\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor((seconds % 3600) / 60);\n  const secs = Math.floor(seconds % 60);\n  return `${hrs}h ${mins}m ${secs}s`;\n}\n\n// ğŸ§  Main Menu + Group Menu Combined\nexport default async function menu(sock, remoteJid, type = \"main\", msg = null) {\n  const runtime = formatUptime(process.uptime());\n  const menuImage = path.resolve(config.image);\n  const modeStatus = getModeStatus();\n  \n  // Check if user is owner to show owner-only commands\n  const userJid = msg?.key?.participant || msg?.key?.remoteJid || remoteJid;\n  const showOwnerCommands = isOwner(userJid);\n\n  // ğŸ’¬ Menu Templates\n  const ownerSection = showOwnerCommands ? `\nâ”â”â”â”ã€” ğŸ‘‘ ğ—¢ğ—ªğ—¡ğ—˜ğ—¥ ğ—–ğ—¢ğ—¡ğ—§ğ—¥ğ—¢ğ—Ÿğ—¦ ã€•â”â”â”â”“\nâ”£â¤ ğŸ”’ .private â€” Enable private mode\nâ”£â¤ ğŸŒ .public â€” Enable public mode\nâ”£â¤ ğŸ›¡ï¸ .sudo @user â€” Add sudo user\nâ”£â¤ ğŸŸ¢ .alwaysonline / .online\nâ”£â¤ âŒ¨ï¸ .autotyping / .typing\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\n` : '';\n\n  const menus = {\n    main: `\nâ•­â”â”â”ã€” ğŸ‘Š *ï¼³ï¼¡ï¼©ï¼´ï¼¡ï¼­ï¼¡  ğ— ğ——* ğŸ‘Š ã€•â”â”â”â•®\nâ”ƒ âš™ï¸ *Version:* ${config.version}\nâ”ƒ â° *Uptime:* ${runtime}\nâ”ƒ ğŸ‘‘ *Owner:* ${config.ownerName}\nâ”ƒ ğŸŒ *Platform:* ${os.platform().toUpperCase()}\nâ”ƒ ğŸ“Š *Mode:* ${modeStatus}\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•¯\n\nâ”â”â”â”ã€” ğŸ§  ğ—šğ—˜ğ—¡ğ—˜ğ—¥ğ—”ğ—Ÿ ğ— ğ—˜ğ—¡ğ—¨ ã€•â”â”â”â”“\nâ”£â¤ ğŸ’¬ .menu\nâ”£â¤ âš¡ .alive\nâ”£â¤ ğŸ“ .ping\nâ”£â¤ ğŸ–¼ï¸ .logo\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\n\n${ownerSection}\n\nâ”â”â”â”ã€” ğŸ‘¥ ğ—šğ—¥ğ—¢ğ—¨ğ—£ ğ— ğ—˜ğ—¡ğ—¨ ã€•â”â”â”â”“\nâ”£â¤ ğŸ§‘â€ğŸ¤â€ğŸ§‘ .groupmenu\nâ”£â¤ ğŸš« .ban / .unban\nâ”£â¤ ğŸª„ .promote / .demote\nâ”£â¤ ğŸ”‡ .mute / .unmute\nâ”£â¤ ğŸ§© .tagall / .hidetag\nâ”£â¤ âš”ï¸ .kick\nâ”£â¤ ğŸŒ .antilink\nâ”£â¤ ğŸ’¬ .welcome / .goodbye\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\n\nâ”â”â”â”ã€” ğŸª„ ğ—™ğ—¨ğ—¡ & ğ—šğ—”ğ— ğ—˜ğ—¦ ã€•â”â”â”â”“\nâ”£â¤ ğŸ² .truth / .dare\nâ”£â¤ â“ .trivia\nâ”£â¤ ğŸ§© .guess\nâ”£â¤ ğŸ•¹ï¸ .tictactoe\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\n\nâ”â”â”â”ã€” ğŸ§­ ğ——ğ—¢ğ—ªğ—¡ğ—Ÿğ—¢ğ—”ğ——ğ—¦ ã€•â”â”â”â”“\nâ”£â¤ ğŸµ .play / .song\nâ”£â¤ ğŸ¥ .video / .ytmp4\nâ”£â¤ ğŸŒ€ .tiktok / .instagram / .facebook\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\n\nâ”â”â”â”ã€” ğŸ”® ğ—”ğ—œ & ğ—¦ğ—˜ğ—”ğ—¥ğ—–ğ—› ã€•â”â”â”â”“\nâ”£â¤ ğŸ¤– .gpt / .cyberai\nâ”£â¤ ğŸ’­ .gemini\nâ”£â¤ ğŸ§® .calculator\nâ”£â¤ ğŸŒ  .imagine\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\n\n> *ã€Œ Saitama MD â€” The Hero Who Coded Too Hard ã€*\n`,\n\n    group: `\nâ•­â”â”â”ã€” ğŸ‘¥ *ï¼³ï¼¡ï¼©ï¼´ï¼¡ï¼­ï¼¡  ğ— ğ—— â€” ğ—šğ—¥ğ—¢ğ—¨ğ—£ ğ— ğ—˜ğ—¡ğ—¨* ğŸ‘¥ ã€•â”â”â”â•®\nâ”ƒ âš™ï¸ *Version:* ${config.version}\nâ”ƒ â° *Uptime:* ${runtime}\nâ”ƒ ğŸ‘‘ *Owner:* ${config.ownerName}\nâ”ƒ ğŸŒ *Platform:* ${os.platform().toUpperCase()}\nâ”ƒ ğŸ“Š *Mode:* ${modeStatus}\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•¯\n\nâ”â”â”â”ã€” ğŸ§‘â€ğŸ¤â€ğŸ§‘ ğ—šğ—¥ğ—¢ğ—¨ğ—£ ğ— ğ—”ğ—¡ğ—”ğ—šğ—˜ğ— ğ—˜ğ—¡ğ—§ ã€•â”â”â”â”“\nâ”£â¤ ğŸš« .ban / .unban â€” Ban or unban users\nâ”£â¤ ğŸª„ .promote / .demote â€” Manage admin roles\nâ”£â¤ ğŸ”‡ .mute / .unmute â€” Control group chat\nâ”£â¤ ğŸ§© .tagall / .hidetag â€” Mention all members\nâ”£â¤ âš”ï¸ .kick â€” Remove member\nâ”£â¤ ğŸŒ .antilink â€” Block links automatically\nâ”£â¤ ğŸ’¬ .welcome / .goodbye â€” Custom greetings\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\n\n> *ã€Œ Saitama MD â€” The Hero Who Coded Too Hard ã€*\n`,\n  };\n\n  const selectedMenu = type === \"group\" ? menus.group : menus.main;\n\n  await sock.sendMessage(remoteJid, {\n    image: { url: menuImage },\n    caption: selectedMenu,\n  });\n}\n","size_bytes":4136},"commands/mute.js":{"content":"export default async function muteGroup(sock, msg) {\n  const from = msg.key.remoteJid;\n  const isGroup = from.endsWith('@g.us');\n  \n  if (!isGroup) {\n    await sock.sendMessage(from, { text: 'âŒ This command only works in groups!' });\n    return;\n  }\n\n  const text = msg.message.conversation || msg.message.extendedTextMessage?.text || '';\n  const command = text.toLowerCase();\n\n  try {\n    if (command === '.mute') {\n      // Mute group - only admins can send messages\n      await sock.groupSettingUpdate(from, 'announcement');\n      await sock.sendMessage(from, { text: 'ğŸ”‡ *Group Muted!*\\n\\nOnly admins can send messages now.' });\n    } else if (command === '.unmute') {\n      // Unmute group - everyone can send messages\n      await sock.groupSettingUpdate(from, 'not_announcement');\n      await sock.sendMessage(from, { text: 'ğŸ”Š *Group Unmuted!*\\n\\nEveryone can send messages now.' });\n    }\n  } catch (err) {\n    await sock.sendMessage(from, { text: `âŒ Error: ${err.message}\\n\\nMake sure the bot is an admin!` });\n  }\n}\n","size_bytes":1034},"commands/ping.js":{"content":"export default {\n  name: \"ping\",\n  description: \"Replies with Pong and latency\",\n  async execute(sock, msg) {\n    const start = Date.now();\n    await sock.sendMessage(msg.key.remoteJid, { text: \"Pong ğŸ“\" });\n    const delta = Date.now() - start;\n    // You can edit to calculate better latency; this gives a quick number.\n    await sock.sendMessage(msg.key.remoteJid, { text: `Latency: ${delta} ms` });\n  }\n};\n","size_bytes":412},"commands/sticker.js":{"content":"","size_bytes":0},"commands/tagall.js":{"content":"export default async function tagAll(sock, msg) {\n  const from = msg.key.remoteJid;\n  const isGroup = from.endsWith('@g.us');\n  \n  if (!isGroup) {\n    await sock.sendMessage(from, { text: 'âŒ This command only works in groups!' });\n    return;\n  }\n\n  try {\n    const metadata = await sock.groupMetadata(from);\n    const participants = metadata.participants;\n    const mentions = participants.map(p => p.id);\n    \n    // Build message with all mentions\n    let message = 'ğŸ“¢ *Tagging All Group Members* ğŸ“¢\\n\\n';\n    participants.forEach((participant, index) => {\n      message += `${index + 1}. @${participant.id.split('@')[0]}\\n`;\n    });\n    \n    await sock.sendMessage(from, { \n      text: message, \n      mentions: mentions \n    });\n  } catch (err) {\n    await sock.sendMessage(from, { text: `âŒ Failed to tag all members: ${err.message}` });\n  }\n}\n","size_bytes":858},"commands/warnings.js":{"content":"import fs from 'fs';\nimport path from 'path';\n\nconst dataDir = 'data';\nconst warningsFile = path.join(dataDir, 'warnings.json');\n\n// Ensure data directory and warnings storage exist\nif (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });\nif (!fs.existsSync(warningsFile)) fs.writeFileSync(warningsFile, JSON.stringify({}));\n\nexport async function warnUser(sock, msg) {\n  const from = msg.key.remoteJid;\n  const mentioned = msg.message.extendedTextMessage?.contextInfo?.mentionedJid;\n  if (!mentioned || mentioned.length === 0) return await sock.sendMessage(from, { text: 'âŒ Mention a user to warn!' });\n\n  const data = JSON.parse(fs.readFileSync(warningsFile, 'utf8'));\n\n  for (let user of mentioned) {\n    if (!data[from]) data[from] = {};\n    if (!data[from][user]) data[from][user] = 0;\n    data[from][user] += 1;\n\n    await sock.sendMessage(from, { text: `âš ï¸ <@${user.split('@')[0]}> has been warned! Total warnings: ${data[from][user]}` });\n  }\n\n  fs.writeFileSync(warningsFile, JSON.stringify(data, null, 2));\n}\n\nexport async function checkWarnings(sock, msg) {\n  const from = msg.key.remoteJid;\n  const mentioned = msg.message.extendedTextMessage?.contextInfo?.mentionedJid;\n  const data = JSON.parse(fs.readFileSync(warningsFile, 'utf8'));\n\n  if (!mentioned || mentioned.length === 0) {\n    return await sock.sendMessage(from, { text: 'âŒ Mention a user to check warnings!' });\n  }\n\n  for (let user of mentioned) {\n    const count = data[from]?.[user] || 0;\n    await sock.sendMessage(from, { text: `âš ï¸ <@${user.split('@')[0]}> has ${count} warning(s)` });\n  }\n}\n","size_bytes":1599},"commands/welcome.js":{"content":"import fs from 'fs';\nconst welcomeFile = 'data/welcome.json';\n\nif (!fs.existsSync(welcomeFile)) fs.writeFileSync(welcomeFile, JSON.stringify({}));\n\nexport async function welcomeMessage(sock, participant) {\n  const from = participant.id.split('-')[0] + '@g.us';\n  const data = JSON.parse(fs.readFileSync(welcomeFile, 'utf8'));\n  const customMsg = data[from]?.welcome || 'ğŸ‘‹ Welcome to the group!';\n  \n  await sock.sendMessage(from, { text: `${customMsg}\\n@${participant.id.split('@')[0]}`, mentions: [participant.id] });\n}\n\nexport async function goodbyeMessage(sock, participant) {\n  const from = participant.id.split('-')[0] + '@g.us';\n  const data = JSON.parse(fs.readFileSync(welcomeFile, 'utf8'));\n  const customMsg = data[from]?.goodbye || 'ğŸ‘‹ Goodbye!';\n\n  await sock.sendMessage(from, { text: `${customMsg}\\n@${participant.id.split('@')[0]}`, mentions: [participant.id] });\n}\n","size_bytes":886},"utils/handler.js":{"content":"","size_bytes":0},"utils/logger.js":{"content":"","size_bytes":0},"commands/botmode.js":{"content":"import chalk from 'chalk';\nimport fs from 'fs';\nimport path from 'path';\n\nconst STATE_FILE = path.join('data', 'bot_state.json');\n\n// Load bot state\nfunction loadState() {\n  try {\n    if (fs.existsSync(STATE_FILE)) {\n      const data = fs.readFileSync(STATE_FILE, 'utf8');\n      return JSON.parse(data);\n    }\n  } catch (error) {\n    console.log(chalk.red('Error loading bot state:'), error.message);\n  }\n  return { privateMode: false, ownerJid: null, sudoUsers: [] };\n}\n\n// Save bot state\nfunction saveState(state) {\n  try {\n    fs.writeFileSync(STATE_FILE, JSON.stringify(state, null, 2), 'utf8');\n  } catch (error) {\n    console.log(chalk.red('Error saving bot state:'), error.message);\n  }\n}\n\n// Get normalized JID (remove device suffix)\nexport function getNormalizedJid(jid) {\n  if (!jid) return null;\n  return jid.split(':')[0];\n}\n\n// Check if user is owner\nexport function isOwner(userJid) {\n  const state = loadState();\n  if (!state.ownerJid) return false;\n  \n  const normalizedUser = getNormalizedJid(userJid);\n  const normalizedOwner = getNormalizedJid(state.ownerJid);\n  \n  // Also check if the user number matches the owner number (handle different JID formats)\n  const userNumber = normalizedUser.split('@')[0];\n  const ownerNumber = normalizedOwner.split('@')[0];\n  \n  return normalizedUser === normalizedOwner || userNumber === ownerNumber;\n}\n\n// Check if user is sudo\nexport function isSudo(userJid) {\n  const state = loadState();\n  const normalizedUser = getNormalizedJid(userJid);\n  return state.sudoUsers.some(sudo => getNormalizedJid(sudo) === normalizedUser);\n}\n\n// Check if user has access\nexport function hasAccess(userJid) {\n  const state = loadState();\n  if (!state.privateMode) return true; // Public mode - everyone has access\n  return isOwner(userJid) || isSudo(userJid);\n}\n\n// Initialize owner from socket\nexport function initializeOwner(sock) {\n  const state = loadState();\n  if (!state.ownerJid && sock.user && sock.user.id) {\n    state.ownerJid = getNormalizedJid(sock.user.id);\n    saveState(state);\n    console.log(chalk.green(`âœ… Bot owner initialized: ${state.ownerJid}`));\n  }\n}\n\n// Set private mode\nexport async function setPrivateMode(sock, msg, enablePrivate) {\n  const from = msg.key.remoteJid;\n  const userJid = msg.key.participant || msg.key.remoteJid;\n  \n  if (!isOwner(userJid)) {\n    await sock.sendMessage(from, { \n      text: 'â›” *Access Denied*\\n\\nğŸ” Only my supreme master can control my privacy settings.\\n\\n_You dare challenge the authority of Saitama?_ ğŸ’ª' \n    });\n    return;\n  }\n  \n  const state = loadState();\n  state.privateMode = enablePrivate;\n  saveState(state);\n  \n  if (enablePrivate) {\n    await sock.sendMessage(from, { \n      text: 'ğŸ”’ *PRIVATE MODE ACTIVATED*\\n\\nâš¡ The bot is now in exclusive mode.\\n\\nOnly authorized users can use my commands.\\n\\n_The power is now restricted..._ ğŸ›¡ï¸' \n    });\n  } else {\n    await sock.sendMessage(from, { \n      text: 'ğŸŒ *PUBLIC MODE ACTIVATED*\\n\\nâš¡ The bot is now open to everyone.\\n\\nAll users can freely use my commands.\\n\\n_The power flows freely once more..._ âœ¨' \n    });\n  }\n}\n\n// Get access denied message\nexport function getAccessDeniedMessage() {\n  const messages = [\n    'â›” *ACCESS DENIED*\\n\\nğŸ” This bot is currently in *PRIVATE MODE*.\\n\\nOnly my supreme master has the authority to command me.\\n\\n_You shall not pass..._ âš”ï¸',\n    'â›” *HALT!*\\n\\nğŸ›¡ï¸ I serve only one master in private mode.\\n\\n_Your commands fall on deaf ears..._ ğŸ‘Š',\n    'â›” *RESTRICTED ACCESS*\\n\\nâš¡ The bot is locked for unauthorized users.\\n\\nMy master alone holds the key.\\n\\n_Know your place..._ ğŸ’¥'\n  ];\n  return messages[Math.floor(Math.random() * messages.length)];\n}\n\n// Get current mode status\nexport function getModeStatus() {\n  const state = loadState();\n  return state.privateMode ? 'ğŸ”’ Private Mode' : 'ğŸŒ Public Mode';\n}\n\n// Add sudo user\nexport async function addSudoUser(sock, msg) {\n  const from = msg.key.remoteJid;\n  const userJid = msg.key.participant || msg.key.remoteJid;\n  \n  if (!isOwner(userJid)) {\n    await sock.sendMessage(from, { \n      text: 'â›” *Access Denied*\\n\\nOnly the bot owner can add sudo users.' \n    });\n    return;\n  }\n  \n  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0];\n  if (!mentionedJid) {\n    await sock.sendMessage(from, { \n      text: 'âŒ Please mention a user to add as sudo.\\n\\n*Example:* .sudo @user' \n    });\n    return;\n  }\n  \n  const state = loadState();\n  const normalizedJid = getNormalizedJid(mentionedJid);\n  \n  if (state.sudoUsers.includes(normalizedJid)) {\n    await sock.sendMessage(from, { \n      text: 'âœ… User is already a sudo user.' \n    });\n    return;\n  }\n  \n  state.sudoUsers.push(normalizedJid);\n  saveState(state);\n  \n  await sock.sendMessage(from, { \n    text: `âœ… *Sudo Access Granted*\\n\\nğŸ” User has been elevated to sudo status.\\n\\nThey can now use commands even in private mode.` \n  });\n}\n","size_bytes":4939},"commands/presence.js":{"content":"// Store presence states\nlet alwaysOnline = false;  // Disabled\nlet autoTyping = false;    // Disabled\n\nexport async function toggleAlwaysOnline(sock, msg) {\n  const from = msg.key.remoteJid;\n  alwaysOnline = !alwaysOnline;\n  \n  if (alwaysOnline) {\n    await sock.sendMessage(from, { text: 'âœ… *Always Online Mode: ENABLED*\\n\\nBot will appear online at all times.' });\n  } else {\n    await sock.sendMessage(from, { text: 'âŒ *Always Online Mode: DISABLED*\\n\\nBot status will return to normal.' });\n  }\n}\n\nexport async function toggleAutoTyping(sock, msg) {\n  const from = msg.key.remoteJid;\n  autoTyping = !autoTyping;\n  \n  if (autoTyping) {\n    await sock.sendMessage(from, { text: 'âœ… *Auto Typing Mode: ENABLED*\\n\\nBot will show typing indicator on incoming messages.' });\n  } else {\n    await sock.sendMessage(from, { text: 'âŒ *Auto Typing Mode: DISABLED*\\n\\nTyping indicator will return to normal.' });\n  }\n}\n\nexport async function handlePresence(sock, from) {\n  // Send typing indicator if auto typing is enabled\n  if (autoTyping && from) {\n    try {\n      await sock.sendPresenceUpdate('composing', from);\n      // Stop typing after 3 seconds\n      setTimeout(async () => {\n        try {\n          await sock.sendPresenceUpdate('paused', from);\n        } catch (error) {\n          // Silently fail if connection is not ready\n        }\n      }, 3000);\n    } catch (error) {\n      // Silently fail if connection is not ready\n    }\n  }\n}\n\nexport async function maintainOnlineStatus(sock) {\n  if (alwaysOnline) {\n    try {\n      await sock.sendPresenceUpdate('available');\n    } catch (error) {\n      // Silently fail if connection is not ready\n      throw error; // Re-throw to be caught by interval handler\n    }\n  }\n}\n\nexport function getPresenceStatus() {\n  return { alwaysOnline, autoTyping };\n}\n","size_bytes":1809}},"version":1}