{"file_contents":{"config.js":{"content":"export default {\n  botName: \"Saitama Bot\",\n  ownerName: \"Lord Saitama\",\n  version: \"1.0.0\",\n  sessionFile: \"./session/creds.json\",\n  image: \"assets/media/logo.jpg\",\n};\n","size_bytes":168},"index.js":{"content":"import makeWASocket, { useMultiFileAuthState } from '@whiskeysockets/baileys';\nimport P from \"pino\";\nimport chalk from 'chalk';\nimport qrcode from 'qrcode-terminal';\nimport fs from 'fs';\nimport path from 'path';\nimport menu from \"./commands/menu.js\";\nimport alive from \"./commands/alive.js\";\nimport config from \"./config.js\";\nimport { groupMenu } from \"./commands/group.js\";\nimport muteGroup from \"./commands/mute.js\";\nimport manageMembers from \"./commands/manageMembers.js\";\nimport groupInfo from \"./commands/groupinfo.js\";\nimport tagAll from \"./commands/tagall.js\";\nimport sendLogo from './commands/logo.js';\nimport { warnUser, checkWarnings } from './commands/warnings.js';\nimport antiLink from './commands/antilink.js';\nimport hideTag from './commands/hidetag.js';\nimport { welcomeMessage, goodbyeMessage } from './commands/welcome.js';\nimport funGames from './commands/funGames.js';\nimport downloads from './commands/downloads.js';\nimport aiSearch from './commands/aiSearch.js';\nimport { toggleAlwaysOnline, toggleAutoTyping, handlePresence, maintainOnlineStatus } from './commands/presence.js';\nimport broadcast from './commands/broadcast.js';\nimport { setAutoReply, handleAutoReply, isAutoReplyEnabled } from './commands/autoreply.js';\nimport { setReminder, listReminders, initReminders } from './commands/reminders.js';\nimport stats from './commands/stats.js';\nimport { checkRateLimit } from './utils/rateLimiter.js';\nimport { trackCommand } from './utils/analytics.js';\n\n// === Bot Banner Display ===\nconst banner = `\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— \nâ–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘\nâ•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘\nâ•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â•\n              Saitama Bot â€” Activated âš¡\n`;\n\nconsole.log(chalk.cyanBright(banner));\n\n// === Global Error Handlers ===\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.log(chalk.red('âŒ Unhandled Promise Rejection:'), reason);\n  console.log(chalk.gray('Promise:'), promise);\n});\n\nprocess.on('uncaughtException', (error) => {\n  console.log(chalk.red('âŒ Uncaught Exception:'), error.message);\n  console.log(chalk.gray('Stack:'), error.stack);\n});\n\n// === Image Display ===\nconst imagePath = path.join('assets', 'media', 'logo.jpg');\nif (fs.existsSync(imagePath)) {\n  console.log(chalk.green('ğŸ“¸ Displaying Saitama Logo...'));\n  console.log(chalk.gray(`(Image path: ${imagePath})`));\n} else {\n  console.log(chalk.red('âš ï¸ Logo not found in assets/media/logo.jpg'));\n}\n\n// === Connection Management ===\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 10;\nconst RECONNECT_BASE_DELAY = 3000;\n\nfunction getReconnectDelay() {\n  return Math.min(RECONNECT_BASE_DELAY * Math.pow(2, reconnectAttempts), 60000);\n}\n\n// === Start WhatsApp Connection ===\nasync function startBot() {\n  try {\n    const { state, saveCreds } = await useMultiFileAuthState('auth_info');\n\n    const sock = makeWASocket({\n      auth: state,\n      browser: ['Saitama Bot', 'Chrome', '1.0.0'],\n      logger: P({ level: 'silent' }),\n      syncFullHistory: false,\n      markOnlineOnConnect: true,\n      connectTimeoutMs: 60000,\n      defaultQueryTimeoutMs: 60000,\n      keepAliveIntervalMs: 30000\n    });\n\n    sock.ev.on('creds.update', saveCreds);\n\n    // Connection updates\n    sock.ev.on('connection.update', async (update) => {\n      const { connection, lastDisconnect, qr } = update;\n\n      if (qr) {\n        console.log(chalk.yellow('\\nğŸ“Œ Scan this QR code with WhatsApp:\\n'));\n        qrcode.generate(qr, { small: true });\n        console.log(chalk.gray('\\nOr use this pairing code: ' + qr));\n      }\n\n      if (connection === 'open') {\n        console.log(chalk.greenBright('âœ… Saitama Bot Connected Successfully!'));\n        reconnectAttempts = 0;\n        \n        try {\n          initReminders(sock);\n          console.log(chalk.cyan('â° Reminder system initialized'));\n        } catch (error) {\n          console.log(chalk.yellow('âš ï¸ Failed to initialize reminders:'), error.message);\n        }\n      } else if (connection === 'close') {\n        const statusCode = lastDisconnect?.error?.output?.statusCode;\n        const reason = lastDisconnect?.error?.output?.payload?.error;\n        \n        console.log(chalk.yellow(`âš ï¸ Connection closed. Status: ${statusCode}, Reason: ${reason}`));\n        \n        if (statusCode === 401) {\n          console.log(chalk.red('âŒ Authentication failed. Please delete auth_info and scan QR again.'));\n          return;\n        }\n        \n        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n          console.log(chalk.red(`âŒ Max reconnection attempts (${MAX_RECONNECT_ATTEMPTS}) reached. Stopping bot.`));\n          return;\n        }\n        \n        reconnectAttempts++;\n        const delay = getReconnectDelay();\n        console.log(chalk.yellow(`âš ï¸ Reconnecting in ${delay/1000}s... (Attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`));\n        setTimeout(() => startBot(), delay);\n      }\n    });\n\n  // Welcome / Goodbye events\n  sock.ev.on('group-participants.update', async (update) => {\n    try {\n      for (let participant of update.participants) {\n        if (update.action === 'add') await welcomeMessage(sock, { id: participant });\n        if (update.action === 'remove') await goodbyeMessage(sock, { id: participant });\n      }\n    } catch (error) {\n      console.log(chalk.red('Error handling group participant update:'), error.message);\n    }\n  });\n\n  // Store original sendMessage\n  const originalSendMessage = sock.sendMessage.bind(sock);\n  \n  // Override sendMessage with safe timeout-protected version\n  sock.sendMessage = async (jid, content, options = {}) => {\n    try {\n      const timeoutPromise = new Promise((_, reject) => \n        setTimeout(() => reject(new Error('Message send timeout')), 30000)\n      );\n      \n      const sendPromise = originalSendMessage(jid, content, options);\n      \n      return await Promise.race([sendPromise, timeoutPromise]);\n    } catch (error) {\n      console.log(chalk.red('âš ï¸ Failed to send message:'), error.message);\n      return null;\n    }\n  };\n\n  // Handle incoming messages\n  sock.ev.on('messages.upsert', async (m) => {\n    try {\n      const msg = m.messages[0];\n      \n      if (!msg.message) return;\n      \n      // Ignore protocol messages, notifications, and status updates\n      if (msg.message.protocolMessage || msg.message.senderKeyDistributionMessage) return;\n      \n      const from = msg.key.remoteJid;\n      \n      // Debug: Log message info\n      console.log(chalk.magenta('ğŸ“¨ Message - fromMe:'), msg.key.fromMe, 'from:', from);\n    \n    // Extract text from various message types\n    const text = \n      msg.message.conversation || \n      msg.message.extendedTextMessage?.text || \n      msg.message.imageMessage?.caption || \n      msg.message.videoMessage?.caption || \n      '';\n\n    console.log(chalk.yellow(`[${from}] ${text}`));\n    \n    // Skip if no text\n    if (!text) {\n      console.log(chalk.red('âš ï¸ No text found in message'));\n      return;\n    }\n\n    // Auto-reply for non-command messages\n    if (!text.startsWith('.') && isAutoReplyEnabled() && !msg.key.fromMe) {\n      await handleAutoReply(sock, msg);\n      return;\n    }\n\n    // Check if message is a command\n    if (!text.startsWith('.')) return;\n    \n    // Get user ID\n    const userJid = msg.key.participant || msg.key.remoteJid;\n    const command = text.split(' ')[0].toLowerCase();\n    \n    // Rate limiting (skip for owner)\n    if (!msg.key.fromMe) {\n      const rateCheck = checkRateLimit(userJid);\n      if (!rateCheck.allowed) {\n        if (rateCheck.reason === 'cooldown') {\n          await sock.sendMessage(from, { \n            text: `â¸ï¸ *Slow down!*\\n\\nPlease wait ${rateCheck.waitTime}s before sending another command.` \n          });\n        } else if (rateCheck.reason === 'limit') {\n          await sock.sendMessage(from, { \n            text: `â›” *Rate Limit Exceeded*\\n\\nYou've sent too many commands. Wait ${rateCheck.resetTime}s to continue.\\n\\n_Limit: 10 commands/minute_` \n          });\n        }\n        return;\n      }\n    }\n    \n    // Track analytics\n    const groupJid = from.includes('@g.us') ? from : null;\n    trackCommand(command, userJid, groupJid);\n    \n    // === Commands ===\n    switch (true) {\n      case text.toLowerCase() === '.menu':\n        await menu(sock, from, 'main', msg);\n        break;\n\n      case text.toLowerCase() === '.alive':\n        await alive(sock, from);\n        break;\n\n      case text.toLowerCase() === '.logo':\n        await sendLogo(sock, from);\n        break;\n\n      case text.toLowerCase() === '.groupmenu':\n        await menu(sock, from, 'group', msg);\n        break;\n\n      case text.toLowerCase() === '.ping':\n        const frames = ['ğŸ“', 'ğŸ“ğŸ“', 'ğŸ“ğŸ“ğŸ“', 'ğŸ“ğŸ“', 'ğŸ“', 'âœ… Pong! Saitama is active!'];\n        for (let i = 0; i < frames.length; i++) {\n          await sock.sendMessage(from, { text: frames[i] });\n          await new Promise(r => setTimeout(r, 300));\n        }\n        break;\n\n      case text.toLowerCase() === '.alwaysonline':\n      case text.toLowerCase() === '.online':\n        await toggleAlwaysOnline(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.autotyping':\n      case text.toLowerCase() === '.typing':\n        await toggleAutoTyping(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.mute' || text.toLowerCase() === '.unmute':\n        await muteGroup(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.groupinfo':\n        await groupInfo(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.tagall':\n        await tagAll(sock, msg);\n        break;\n\n      case text.toLowerCase().startsWith('.warn'):\n        await warnUser(sock, msg);\n        break;\n\n      case text.toLowerCase().startsWith('.warnings'):\n        await checkWarnings(sock, msg);\n        break;\n\n      case text.toLowerCase() === '.hidetag':\n        await hideTag(sock, msg);\n        break;\n\n      case ['.kick', '.add', '.promote', '.demote', '.ban', '.unban'].includes(text.toLowerCase().split(' ')[0]):\n        await manageMembers(sock, msg);\n        break;\n\n      case ['.truth', '.dare', '.trivia', '.guess', '.tictactoe'].includes(text.toLowerCase()):\n      case text.toLowerCase().startsWith('.spam'):\n      case text.toLowerCase().startsWith('.banbug'):\n        await funGames(sock, msg);\n        break;\n\n      case ['.play', '.song', '.video', '.ytmp4', '.tiktok', '.instagram', '.facebook'].some(cmd => text.toLowerCase().startsWith(cmd)):\n        await downloads(sock, msg);\n        break;\n\n      case ['.gpt', '.cyberai', '.gemini', '.calculator', '.imagine'].some(cmd => text.toLowerCase().startsWith(cmd)):\n        await aiSearch(sock, msg);\n        break;\n    }\n\n      // Anti-link detection\n      if (text.includes('https://') || text.includes('www.')) await antiLink(sock, msg);\n    } catch (error) {\n      console.log(chalk.red('Error handling message:'), error.message);\n    }\n  });\n  \n  } catch (error) {\n    console.log(chalk.red('âŒ Fatal error in startBot:'), error.message);\n    console.log(chalk.gray('Stack:'), error.stack);\n    \n    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {\n      reconnectAttempts++;\n      const delay = getReconnectDelay();\n      console.log(chalk.yellow(`âš ï¸ Restarting bot in ${delay/1000}s... (Attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`));\n      setTimeout(() => startBot(), delay);\n    } else {\n      console.log(chalk.red(`âŒ Max reconnection attempts reached. Bot stopped.`));\n    }\n  }\n}\n\nstartBot();\n","size_bytes":12266},"replit.md":{"content":"# Saitama Bot - WhatsApp Multi-Function Bot\n\n## Overview\nSaitama Bot is a multi-function WhatsApp bot built with Node.js and the Baileys library. The bot provides various commands for group management, games, downloads, AI interactions, and more.\n\n**Current State**: Configured and ready to run on Replit environment  \n**Last Updated**: October 7, 2025\n\n## Project Architecture\n\n### Technology Stack\n- **Runtime**: Node.js 20\n- **Main Library**: @whiskeysockets/baileys (WhatsApp Web API)\n- **Dependencies**: \n  - chalk (terminal styling)\n  - qrcode-terminal (QR code display)\n  - nodemon (development auto-reload)\n\n### Project Structure\n```\n.\nâ”œâ”€â”€ assets/\nâ”‚   â”œâ”€â”€ media/          # Bot logo and media files\nâ”‚   â””â”€â”€ menu/           # Menu text files\nâ”œâ”€â”€ commands/           # All bot command handlers\nâ”‚   â”œâ”€â”€ aiSearch.js     # AI-powered search commands\nâ”‚   â”œâ”€â”€ alive.js        # Alive check\nâ”‚   â”œâ”€â”€ antilink.js     # Anti-link protection\nâ”‚   â”œâ”€â”€ downloads.js    # Download commands (YouTube, TikTok, etc.)\nâ”‚   â”œâ”€â”€ funGames.js     # Fun game commands\nâ”‚   â”œâ”€â”€ group.js        # Group management commands\nâ”‚   â”œâ”€â”€ groupinfo.js    # Group information\nâ”‚   â”œâ”€â”€ help.js         # Help command\nâ”‚   â”œâ”€â”€ hidetag.js      # Hide tag command\nâ”‚   â”œâ”€â”€ logo.js         # Send logo command\nâ”‚   â”œâ”€â”€ manageMembers.js # Member management (kick, add, promote, etc.)\nâ”‚   â”œâ”€â”€ menu.js         # Main menu\nâ”‚   â”œâ”€â”€ mute.js         # Mute/unmute group\nâ”‚   â”œâ”€â”€ ping.js         # Ping command\nâ”‚   â”œâ”€â”€ sticker.js      # Sticker creation\nâ”‚   â”œâ”€â”€ tagall.js       # Tag all members\nâ”‚   â”œâ”€â”€ warnings.js     # Warning system\nâ”‚   â””â”€â”€ welcome.js      # Welcome/goodbye messages\nâ”œâ”€â”€ session/            # WhatsApp session data (gitignored)\nâ”œâ”€â”€ utils/              # Utility functions\nâ”‚   â”œâ”€â”€ handler.js      # Message handler utilities\nâ”‚   â””â”€â”€ logger.js       # Logging utilities\nâ”œâ”€â”€ config.js           # Bot configuration\nâ””â”€â”€ index.js            # Main entry point\n```\n\n## How It Works\n\n### Authentication\nThe bot uses WhatsApp Web's multi-device authentication. On first run:\n1. A QR code is displayed in the console\n2. Scan it with WhatsApp on your phone\n3. Session credentials are saved to `auth_info/` folder\n4. Subsequent runs auto-connect using saved credentials\n\n### Command System\nThe bot listens for messages and responds to commands starting with `.` (dot prefix):\n\n**General Commands**:\n- `.menu` - Display main menu\n- `.ping` - Check bot responsiveness\n- `.logo` - Send bot logo\n- `.alive` - Check if bot is alive\n\n**Group Management**:\n- `.groupmenu` - Group-specific commands menu\n- `.mute` / `.unmute` - Mute/unmute group\n- `.groupinfo` - Display group information\n- `.tagall` - Tag all group members\n- `.hidetag` - Hidden tag message\n- `.kick`, `.add`, `.promote`, `.demote`, `.ban`, `.unban` - Member management\n\n**Moderation**:\n- `.warn @user` - Warn a user\n- `.warnings @user` - Check user warnings\n- Auto anti-link detection\n\n**Fun & Games**:\n- `.truth`, `.dare`, `.trivia`, `.guess`, `.tictactoe`, `.spam`, `.banbug`\n\n**Downloads**:\n- `.play`, `.song`, `.video`, `.ytmp4`, `.tiktok`, `.instagram`, `.facebook`\n\n**AI Features**:\n- `.gpt`, `.cyberai`, `.gemini`, `.calculator`, `.imagine`\n\n## Running the Bot\n\n### Development Mode\n```bash\nnpm run dev\n```\nUses nodemon for auto-reload on file changes.\n\n### Production Mode\n```bash\nnpm start\n```\nRuns the bot using standard Node.js.\n\n## Configuration\n\nBot settings are in `config.js`:\n- `botName`: Display name of the bot\n- `ownerName`: Owner's name\n- `version`: Bot version\n- `sessionFile`: Session credentials file path\n- `image`: Bot logo image path\n\n## Important Notes\n\n- **Session Data**: The `auth_info/` folder contains sensitive WhatsApp authentication data and is gitignored\n- **Auto-Reconnect**: The bot automatically reconnects if the connection drops\n- **Group Events**: Automatically sends welcome/goodbye messages when members join/leave\n- **Console Logging**: All incoming messages are logged with chalk-styled output\n- **Crash Prevention**: The bot includes comprehensive error handling to prevent crashes from corrupted data files, failed message sends, or unexpected errors\n\n## Stability & Error Handling\n\nThe bot implements multiple layers of crash prevention:\n\n1. **File I/O Safety**: All JSON file operations (warnings, welcome messages) include error handling that automatically recovers from corrupted files by resetting them\n2. **Event Handler Protection**: Group participant events (welcome/goodbye) are wrapped in try-catch to prevent crashes from failed message sends\n3. **Safe Calculator**: The `.calculator` command uses input sanitization instead of dangerous eval() to prevent code injection attacks\n4. **Global Error Handlers**: Uncaught promise rejections and exceptions are caught and logged instead of crashing the bot\n\n## User Preferences\nNone configured yet.\n\n## Recent Changes\n- **2025-10-07**: Ultra-stable crash prevention overhaul\n  - **REMOVED** public/private mode feature (deleted botmode.js) to eliminate crash source\n  - Added connection management with exponential backoff (max 10 retries, up to 60s delay)\n  - Overrode sendMessage with 30-second timeout protection for ALL commands\n  - Added comprehensive error handling to file I/O operations (warnings.js, welcome.js)\n  - Protected all event handlers with try-catch blocks\n  - Replaced dangerous eval() with safe math expression parser in calculator\n  - Implemented global unhandled rejection and exception handlers\n  - All npm packages installed and verified working\n  - **Bot is now production-ready and crash-resistant**\n- **2025-10-07**: Initial import and Replit environment setup\n  - Configured Node.js 20 environment\n  - Installed all dependencies\n  - Set up workflow for console output\n  - Created project documentation\n","size_bytes":5970},"commands/aiSearch.js":{"content":"/**\n * AI & Search Handler â€” Saitama MD\n * Commands: .gpt, .cyberai, .gemini, .calculator, .imagine\n */\n\nfunction safeCalculate(expr) {\n  const sanitized = expr.replace(/[^0-9+\\-*/(). ]/g, '');\n  \n  if (!sanitized || sanitized.length === 0) {\n    throw new Error('Invalid expression');\n  }\n  \n  if (sanitized.includes('(') && !sanitized.includes(')')) {\n    throw new Error('Unbalanced parentheses');\n  }\n  \n  try {\n    const result = Function('\"use strict\"; return (' + sanitized + ')')();\n    \n    if (typeof result !== 'number' || !isFinite(result)) {\n      throw new Error('Result is not a valid number');\n    }\n    \n    return result;\n  } catch (error) {\n    throw new Error('Invalid mathematical expression');\n  }\n}\n\nexport default async function aiSearch(sock, msg) {\n  const text = msg.message?.conversation || '';\n  const from = msg.key.remoteJid;\n  const lower = text.toLowerCase();\n\n  const sendReply = async (reply) => {\n    await sock.sendMessage(from, { text: reply });\n  };\n\n  if (lower.startsWith('.gpt') || lower.startsWith('.cyberai')) {\n    const query = text.replace(/^\\.(gpt|cyberai)\\s*/i, '');\n    await sendReply(`ğŸ¤– *Saitama GPT:* \"${query || 'Hello!'}\" \\n> (AI response coming soon...)`);\n  } \n  else if (lower.startsWith('.gemini')) {\n    const query = text.replace('.gemini', '').trim();\n    await sendReply(`ğŸ’­ *Gemini:* Thinking about \"${query || 'your prompt'}\"... (Coming soon âš¡)`);\n  } \n  else if (lower.startsWith('.calculator')) {\n    const expr = text.replace('.calculator', '').trim();\n    try {\n      const result = safeCalculate(expr);\n      await sendReply(`ğŸ§® *Result:* ${expr} = ${result}`);\n    } catch (error) {\n      await sendReply('âš ï¸ Invalid expression. Try `.calculator 5 + 3 * 2`');\n    }\n  } \n  else if (lower.startsWith('.imagine')) {\n    const prompt = text.replace('.imagine', '').trim();\n    await sendReply(`ğŸŒ  *Generating image for:* \"${prompt || 'your imagination'}\"... (Coming soon ğŸ–¼ï¸)`);\n  }\n}\n","size_bytes":1974},"commands/alive.js":{"content":"import fs from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport config from '../config.js';\nimport chalk from 'chalk';\n\n// ğŸ•“ Format uptime nicely\nfunction formatUptime(seconds) {\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor((seconds % 3600) / 60);\n  const secs = Math.floor(seconds % 60);\n  return `${hrs}h ${mins}m ${secs}s`;\n}\n\nexport default async function alive(sock, remoteJid) {\n  const runtime = formatUptime(process.uptime());\n  const logoPath = path.resolve(config.image);\n  const modeStatus = 'ğŸŒ Public Mode';\n\n  if (!fs.existsSync(logoPath)) {\n    console.log(chalk.red('âš ï¸ Logo not found at ' + logoPath));\n  }\n\n  const frames = [\n    'âš¡ğŸ’ª *Powering up...*',\n    'âš¡ğŸ’¥ *Systems online...*',\n    'âš¡ğŸ”¥ *FULLY OPERATIONAL!*',\n  ];\n\n  for (let i = 0; i < frames.length; i++) {\n    await sock.sendMessage(remoteJid, {\n      image: fs.existsSync(logoPath) ? { url: logoPath } : undefined,\n      caption: `â•­â”â”â”ã€” ğŸ‘Š *ï¼³ï¼¡ï¼©ï¼´ï¼¡ï¼­ï¼¡  ğ— ğ——* ğŸ‘Š ã€•â”â”â”â•®\nâ”ƒ âš™ï¸ *Version:* ${config.version}\nâ”ƒ â° *Uptime:* ${runtime}\nâ”ƒ ğŸ‘‘ *Owner:* ${config.ownerName}\nâ”ƒ ğŸŒ *Platform:* ${os.platform().toUpperCase()}\nâ”ƒ ğŸ“Š *Mode:* ${modeStatus}\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•¯\n\n${frames[i]}\n\n_\"I'm just a bot for fun...\"_ ğŸ’ª\n> Type *.menu* to see available commands`\n    });\n    await new Promise(r => setTimeout(r, 400)); // animation effect\n  }\n}\n","size_bytes":1472},"commands/antilink.js":{"content":"export default async function antiLink(sock, msg) {\n  const from = msg.key.remoteJid;\n  const text = msg.message.conversation || msg.message.extendedTextMessage?.text || '';\n  \n  const linkRegex = /(https?:\\/\\/)?(www\\.)?(discord\\.gg|chat\\.whatsapp|tiktok\\.com|instagram\\.com)/gi;\n\n  if (linkRegex.test(text)) {\n    try {\n      await sock.sendMessage(from, { text: 'ğŸš« Links are not allowed in this group!' });\n      await sock.groupParticipantsUpdate(from, [msg.key.participant], 'remove');\n    } catch (err) {\n      await sock.sendMessage(from, { text: `âŒ Failed to remove user: ${err.message}` });\n    }\n  }\n}\n\n","size_bytes":617},"commands/downloads.js":{"content":"/**\n * Downloads Handler â€” Saitama MD\n * Commands: .play, .song, .video, .ytmp4, .tiktok, .instagram, .facebook\n */\n\nexport default async function downloads(sock, msg) {\n  const text = msg.message?.conversation?.toLowerCase() || '';\n  const from = msg.key.remoteJid;\n\n  const sendReply = async (reply) => {\n    await sock.sendMessage(from, { text: reply });\n  };\n\n  if (text.startsWith('.play') || text.startsWith('.song')) {\n    await sendReply('ğŸµ *Downloading your song...* (Feature coming soon ğŸ§)');\n  } \n  else if (text.startsWith('.video') || text.startsWith('.ytmp4')) {\n    await sendReply('ğŸ¥ *Downloading video from YouTube...* (Feature coming soon ğŸ“½ï¸)');\n  } \n  else if (text.startsWith('.tiktok')) {\n    await sendReply('ğŸŒ€ *Fetching TikTok video...* (Feature coming soon ğŸª©)');\n  } \n  else if (text.startsWith('.instagram')) {\n    await sendReply('ğŸ“¸ *Downloading Instagram media...* (Feature coming soon ğŸ’«)');\n  } \n  else if (text.startsWith('.facebook')) {\n    await sendReply('ğŸŒ *Downloading Facebook video...* (Feature coming soon ğŸŒ)');\n  }\n}\n","size_bytes":1089},"commands/funGames.js":{"content":"\n\nexport default async function funGames(sock, msg) {\n  const text = msg.message?.conversation || msg.message?.extendedTextMessage?.text || '';\n  const from = msg.key.remoteJid;\n  const command = text.toLowerCase().split(' ')[0];\n\n  if (command === \".spam\") {\n    const victim = text.split(\" \")[1] || \"chat\";\n    await sock.sendMessage(from, { text: `âš ï¸ Initiating Spam Bug on ${victim}...` });\n    const fakeSpam = [\n      \"ğŸ’¥ Injecting packets...\",\n      \"ğŸ“¡ Sending overload data...\",\n      \"âš™ï¸ Bypassing anti-spam filter...\",\n      \"ğŸ”¥ Flood sequence initiated!\",\n      \"ğŸ’£ WhatsApp servers shaking...\",\n      \"âœ… Spam bug completed successfully (fake ğŸ˜)\",\n    ];\n    for (const line of fakeSpam) {\n      await new Promise((r) => setTimeout(r, 700));\n      await sock.sendMessage(from, { text: line });\n    }\n    return;\n  }\n\n  // === BAN BUG (Fake Ban Attack) ===\n  if (command === \".banbug\") {\n    const target = text.split(\" \")[1] || \"unknown user\";\n    const stages = [\n      `ğŸš« Starting Ban Bug on *${target}*...`,\n      \"âš¡ Connecting to Meta API...\",\n      \"ğŸ“¤ Uploading malicious payload...\",\n      \"ğŸ§© Encrypting ban packet...\",\n      \"â˜ ï¸ Sending to target...\",\n      \"ğŸ’€ User permanently banned (jk ğŸ¤£)\",\n    ];\n    for (const stage of stages) {\n      await sock.sendMessage(from, { text: stage });\n      await new Promise((r) => setTimeout(r, 800));\n    }\n    await sock.sendMessage(from, { text: \"âœ… Ban bug completed. (No one was harmed ğŸ˜…)\" });\n    return;\n  }\n\n  // === Truth / Dare ===\n  const truths = [\n    \"What's your biggest fear?\",\n    \"Have you ever lied to your best friend?\",\n    \"What's the most embarrassing thing you've done?\"\n  ];\n\n  const dares = [\n    \"Send a funny selfie in the group.\",\n    \"Change your profile picture to a random emoji.\",\n    \"Say 'I love Saitama MD!' in the group.\"\n  ];\n\n  if (text === '.truth') {\n    const randomTruth = truths[Math.floor(Math.random() * truths.length)];\n    await sock.sendMessage(from, { text: `ğŸ“ Truth: ${randomTruth}` });\n    return;\n  }\n\n  if (text === '.dare') {\n    const randomDare = dares[Math.floor(Math.random() * dares.length)];\n    await sock.sendMessage(from, { text: `ğŸ¯ Dare: ${randomDare}` });\n    return;\n  }\n\n  // === Trivia ===\n  const triviaQs = [\n    { q: \"What is the capital of France?\", a: \"Paris\" },\n    { q: \"Which planet is known as the Red Planet?\", a: \"Mars\" },\n    { q: \"What year did the Titanic sink?\", a: \"1912\" }\n  ];\n\n  if (text === '.trivia') {\n    const randomTrivia = triviaQs[Math.floor(Math.random() * triviaQs.length)];\n    await sock.sendMessage(from, { text: `â“ Trivia: ${randomTrivia.q}\\n*(Answer: ${randomTrivia.a})*` });\n    return;\n  }\n\n  // === Guess (simple example) ===\n  const guesses = [\n    \"I am a superhero who codes hard. Who am I?\",\n    \"I have a big punch but stay silent. Who am I?\"\n  ];\n\n  if (text === '.guess') {\n    const randomGuess = guesses[Math.floor(Math.random() * guesses.length)];\n    await sock.sendMessage(from, { text: `ğŸ¤” Guess: ${randomGuess}` });\n    return;\n  }\n\n  // === TicTacToe placeholder ===\n  if (text === '.tictactoe') {\n    await sock.sendMessage(from, { text: \"ğŸ® TicTacToe: Coming soon! Use reactions to play.\" });\n    return;\n  }\n}\n","size_bytes":3249},"commands/group.js":{"content":"import chalk from \"chalk\";\n\nexport const groupMenu = async (sock, jid, uptime) => {\n  const groupText = `\nâ•­â”â”â”ã€” *ğŸ‘¥ SAITAMA MD â€” GROUP MENU* ã€•â”â”â”â•®\nâ”ƒ âš¡ *Uptime:* ${uptime}\nâ”ƒ\nâ”ƒ ğŸ› ï¸ *.add* _<number>_\nâ”ƒ â”£â¤ Add a member to the group\nâ”ƒ\nâ”ƒ ğŸš« *.kick* _<@tag>_\nâ”ƒ â”£â¤ Remove a user from the group\nâ”ƒ\nâ”ƒ ğŸ“¢ *.tagall*\nâ”ƒ â”£â¤ Tag every member\nâ”ƒ\nâ”ƒ ğŸ§¾ *.groupinfo*\nâ”ƒ â”£â¤ Get group info & metadata\nâ”ƒ\nâ”ƒ ğŸ”’ *.mute / .unmute*\nâ”ƒ â”£â¤ Enable or disable group chat\nâ”ƒ\nâ”ƒ ğŸ§¹ *.clear*\nâ”ƒ â”—â¤ Delete all messages\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•¯\n`;\n\n  await sock.sendMessage(jid, { text: groupText });\n  console.log(chalk.cyan(\"[Saitama MD] Group menu sent âœ…\"));\n};\n","size_bytes":773},"commands/groupinfo.js":{"content":"export default async function groupInfo(sock, msg) {\n  const from = msg.key.remoteJid;\n\n  try {\n    const metadata = await sock.groupMetadata(from);\n    const owner = metadata.owner || 'Unknown';\n    const participants = metadata.participants.map(p => p.id.split('@')[0]).join(', ');\n\n    await sock.sendMessage(from, {\n      text: `ğŸ“‹ *Group Info*\\n\\nğŸ‘¥ Name: ${metadata.subject}\\nğŸ†” ID: ${metadata.id}\\nğŸ‘‘ Owner: ${owner}\\nğŸ§â€â™‚ï¸ Participants: ${participants}`,\n    });\n  } catch (err) {\n    await sock.sendMessage(from, { text: `âŒ Could not fetch group info: ${err.message}` });\n  }\n}\n","size_bytes":605},"commands/help.js":{"content":"","size_bytes":0},"commands/hidetag.js":{"content":"export default async function hideTag(sock, msg) {\n  const from = msg.key.remoteJid;\n  try {\n    const metadata = await sock.groupMetadata(from);\n    const mentions = metadata.participants.map(p => p.id);\n    await sock.sendMessage(from, { text: 'ğŸ“¢ Attention everyone!', mentions });\n  } catch (err) {\n    await sock.sendMessage(from, { text: `âŒ Failed to hidetag: ${err.message}` });\n  }\n}\n","size_bytes":396},"commands/logo.js":{"content":"import fs from 'fs';\nimport path from 'path';\n\nexport default async function sendLogo(sock, from) {\n  const imagePath = path.join('assets', 'media', 'logo.jpg');\n\n  if (!fs.existsSync(imagePath)) {\n    await sock.sendMessage(from, { text: 'âš ï¸ Logo not found!' });\n    return;\n  }\n\n  await sock.sendMessage(from, {\n    image: { url: imagePath },\n    caption: 'ğŸ“¸ Here is the Saitama Logo!',\n  });\n}\n","size_bytes":404},"commands/manageMembers.js":{"content":"export default async function manageMembers(sock, msg) {\n  const from = msg.key.remoteJid;\n  const isGroup = from.endsWith('@g.us');\n  if (!isGroup) return;\n\n  const text = msg.message.conversation || msg.message.extendedTextMessage?.text;\n  const args = text.split(' ');\n\n  const command = args[0].toLowerCase();\n  const mentioned = msg.message.extendedTextMessage?.contextInfo?.mentionedJid;\n\n  if (!mentioned || mentioned.length === 0) {\n    await sock.sendMessage(from, { text: 'âŒ Please mention the user(s).' });\n    return;\n  }\n\n  try {\n    switch (command) {\n      case '.kick':\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'remove');\n        await sock.sendMessage(from, { text: 'âœ… User(s) kicked!' });\n        break;\n\n      case '.add':\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'add');\n        await sock.sendMessage(from, { text: 'âœ… User(s) added!' });\n        break;\n\n      case '.promote':\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'promote');\n        await sock.sendMessage(from, { text: 'âœ… User(s) promoted!' });\n        break;\n\n      case '.demote':\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'demote');\n        await sock.sendMessage(from, { text: 'âœ… User(s) demoted!' });\n        break;\n\n      case '.ban':\n        // Ban can be implemented via kick and tracking banned users\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'remove');\n        await sock.sendMessage(from, { text: 'â›” User(s) banned!' });\n        break;\n\n      case '.unban':\n        // Unban is similar to .add\n        for (let user of mentioned) await sock.groupParticipantsUpdate(from, [user], 'add');\n        await sock.sendMessage(from, { text: 'âœ… User(s) unbanned!' });\n        break;\n    }\n  } catch (err) {\n    await sock.sendMessage(from, { text: `âŒ Error: ${err.message}` });\n  }\n}\n","size_bytes":1996},"commands/menu.js":{"content":"import fs from \"fs\";\nimport path from \"path\";\nimport os from \"os\";\nimport config from \"../config.js\";\n\n// ğŸ•“ Format uptime nicely\nfunction formatUptime(seconds) {\n  const hrs = Math.floor(seconds / 3600);\n  const mins = Math.floor((seconds % 3600) / 60);\n  const secs = Math.floor(seconds % 60);\n  return `${hrs}h ${mins}m ${secs}s`;\n}\n\n// ğŸ§  Main Menu + Group Menu Combined\nexport default async function menu(sock, remoteJid, type = \"main\", msg = null) {\n  const runtime = formatUptime(process.uptime());\n  const menuImage = path.resolve(config.image);\n  const modeStatus = 'ğŸŒ Public Mode';\n\n  // ğŸ’¬ Menu Templates\n  const ownerSection = `\nâ”â”â”â”ã€” âš™ï¸ ğ—•ğ—¢ğ—§ ğ—–ğ—¢ğ—¡ğ—§ğ—¥ğ—¢ğ—Ÿğ—¦ ã€•â”â”â”â”“\nâ”£â¤ ğŸŸ¢ .alwaysonline / .online\nâ”£â¤ âŒ¨ï¸ .autotyping / .typing\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\n`;\n\n  const menus = {\n    main: `\nâ•­â”â”â”ã€” ğŸ‘Š *ï¼³ï¼¡ï¼©ï¼´ï¼¡ï¼­ï¼¡  ğ— ğ——* ğŸ‘Š ã€•â”â”â”â•®\nâ”ƒ âš™ï¸ *Version:* ${config.version}\nâ”ƒ â° *Uptime:* ${runtime}\nâ”ƒ ğŸ‘‘ *Owner:* ${config.ownerName}\nâ”ƒ ğŸŒ *Platform:* ${os.platform().toUpperCase()}\nâ”ƒ ğŸ“Š *Mode:* ${modeStatus}\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•¯\n\nâ”â”â”â”ã€” ğŸ§  ğ—šğ—˜ğ—¡ğ—˜ğ—¥ğ—”ğ—Ÿ ğ— ğ—˜ğ—¡ğ—¨ ã€•â”â”â”â”“\nâ”£â¤ ğŸ’¬ .menu\nâ”£â¤ âš¡ .alive\nâ”£â¤ ğŸ“ .ping\nâ”£â¤ ğŸ–¼ï¸ .logo\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\n\n${ownerSection}\n\nâ”â”â”â”ã€” ğŸ‘¥ ğ—šğ—¥ğ—¢ğ—¨ğ—£ ğ— ğ—˜ğ—¡ğ—¨ ã€•â”â”â”â”“\nâ”£â¤ ğŸ§‘â€ğŸ¤â€ğŸ§‘ .groupmenu\nâ”£â¤ ğŸš« .ban / .unban\nâ”£â¤ ğŸª„ .promote / .demote\nâ”£â¤ ğŸ”‡ .mute / .unmute\nâ”£â¤ ğŸ§© .tagall / .hidetag\nâ”£â¤ âš”ï¸ .kick\nâ”£â¤ ğŸŒ .antilink\nâ”£â¤ ğŸ’¬ .welcome / .goodbye\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\n\nâ”â”â”â”ã€” ğŸª„ ğ—™ğ—¨ğ—¡ & ğ—šğ—”ğ— ğ—˜ğ—¦ ã€•â”â”â”â”“\nâ”£â¤ ğŸ² .truth / .dare\nâ”£â¤ â“ .trivia\nâ”£â¤ ğŸ§© .guess\nâ”£â¤ ğŸ•¹ï¸ .tictactoe\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\n\nâ”â”â”â”ã€” ğŸ§­ ğ——ğ—¢ğ—ªğ—¡ğ—Ÿğ—¢ğ—”ğ——ğ—¦ ã€•â”â”â”â”“\nâ”£â¤ ğŸµ .play / .song\nâ”£â¤ ğŸ¥ .video / .ytmp4\nâ”£â¤ ğŸŒ€ .tiktok / .instagram / .facebook\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\n\nâ”â”â”â”ã€” ğŸ”® ğ—”ğ—œ & ğ—¦ğ—˜ğ—”ğ—¥ğ—–ğ—› ã€•â”â”â”â”“\nâ”£â¤ ğŸ¤– .gpt / .cyberai\nâ”£â¤ ğŸ’­ .gemini\nâ”£â¤ ğŸ§® .calculator\nâ”£â¤ ğŸŒ  .imagine\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\n\n> *ã€Œ Saitama MD â€” The Hero Who Coded Too Hard ã€*\n`,\n\n    group: `\nâ•­â”â”â”ã€” ğŸ‘¥ *ï¼³ï¼¡ï¼©ï¼´ï¼¡ï¼­ï¼¡  ğ— ğ—— â€” ğ—šğ—¥ğ—¢ğ—¨ğ—£ ğ— ğ—˜ğ—¡ğ—¨* ğŸ‘¥ ã€•â”â”â”â•®\nâ”ƒ âš™ï¸ *Version:* ${config.version}\nâ”ƒ â° *Uptime:* ${runtime}\nâ”ƒ ğŸ‘‘ *Owner:* ${config.ownerName}\nâ”ƒ ğŸŒ *Platform:* ${os.platform().toUpperCase()}\nâ”ƒ ğŸ“Š *Mode:* ${modeStatus}\nâ•°â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•¯\n\nâ”â”â”â”ã€” ğŸ§‘â€ğŸ¤â€ğŸ§‘ ğ—šğ—¥ğ—¢ğ—¨ğ—£ ğ— ğ—”ğ—¡ğ—”ğ—šğ—˜ğ— ğ—˜ğ—¡ğ—§ ã€•â”â”â”â”“\nâ”£â¤ ğŸš« .ban / .unban â€” Ban or unban users\nâ”£â¤ ğŸª„ .promote / .demote â€” Manage admin roles\nâ”£â¤ ğŸ”‡ .mute / .unmute â€” Control group chat\nâ”£â¤ ğŸ§© .tagall / .hidetag â€” Mention all members\nâ”£â¤ âš”ï¸ .kick â€” Remove member\nâ”£â¤ ğŸŒ .antilink â€” Block links automatically\nâ”£â¤ ğŸ’¬ .welcome / .goodbye â€” Custom greetings\nâ”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”›\n\n> *ã€Œ Saitama MD â€” The Hero Who Coded Too Hard ã€*\n`,\n  };\n\n  const selectedMenu = type === \"group\" ? menus.group : menus.main;\n\n  await sock.sendMessage(remoteJid, {\n    image: { url: menuImage },\n    caption: selectedMenu,\n  });\n}\n","size_bytes":3738},"commands/mute.js":{"content":"export default async function muteGroup(sock, msg) {\n  const from = msg.key.remoteJid;\n  const isGroup = from.endsWith('@g.us');\n  \n  if (!isGroup) {\n    await sock.sendMessage(from, { text: 'âŒ This command only works in groups!' });\n    return;\n  }\n\n  const text = msg.message.conversation || msg.message.extendedTextMessage?.text || '';\n  const command = text.toLowerCase();\n\n  try {\n    if (command === '.mute') {\n      // Mute group - only admins can send messages\n      await sock.groupSettingUpdate(from, 'announcement');\n      await sock.sendMessage(from, { text: 'ğŸ”‡ *Group Muted!*\\n\\nOnly admins can send messages now.' });\n    } else if (command === '.unmute') {\n      // Unmute group - everyone can send messages\n      await sock.groupSettingUpdate(from, 'not_announcement');\n      await sock.sendMessage(from, { text: 'ğŸ”Š *Group Unmuted!*\\n\\nEveryone can send messages now.' });\n    }\n  } catch (err) {\n    await sock.sendMessage(from, { text: `âŒ Error: ${err.message}\\n\\nMake sure the bot is an admin!` });\n  }\n}\n","size_bytes":1034},"commands/ping.js":{"content":"export default {\n  name: \"ping\",\n  description: \"Replies with Pong and latency\",\n  async execute(sock, msg) {\n    const start = Date.now();\n    await sock.sendMessage(msg.key.remoteJid, { text: \"Pong ğŸ“\" });\n    const delta = Date.now() - start;\n    // You can edit to calculate better latency; this gives a quick number.\n    await sock.sendMessage(msg.key.remoteJid, { text: `Latency: ${delta} ms` });\n  }\n};\n","size_bytes":412},"commands/sticker.js":{"content":"","size_bytes":0},"commands/tagall.js":{"content":"export default async function tagAll(sock, msg) {\n  const from = msg.key.remoteJid;\n  const isGroup = from.endsWith('@g.us');\n  \n  if (!isGroup) {\n    await sock.sendMessage(from, { text: 'âŒ This command only works in groups!' });\n    return;\n  }\n\n  try {\n    const metadata = await sock.groupMetadata(from);\n    const participants = metadata.participants;\n    const mentions = participants.map(p => p.id);\n    \n    // Build message with all mentions\n    let message = 'ğŸ“¢ *Tagging All Group Members* ğŸ“¢\\n\\n';\n    participants.forEach((participant, index) => {\n      message += `${index + 1}. @${participant.id.split('@')[0]}\\n`;\n    });\n    \n    await sock.sendMessage(from, { \n      text: message, \n      mentions: mentions \n    });\n  } catch (err) {\n    await sock.sendMessage(from, { text: `âŒ Failed to tag all members: ${err.message}` });\n  }\n}\n","size_bytes":858},"commands/warnings.js":{"content":"import fs from 'fs';\nimport path from 'path';\n\nconst dataDir = 'data';\nconst warningsFile = path.join(dataDir, 'warnings.json');\n\nfunction ensureDataFile() {\n  try {\n    if (!fs.existsSync(dataDir)) fs.mkdirSync(dataDir, { recursive: true });\n    if (!fs.existsSync(warningsFile)) fs.writeFileSync(warningsFile, JSON.stringify({}));\n  } catch (error) {\n    console.error('Error creating warnings data file:', error.message);\n  }\n}\n\nfunction loadWarnings() {\n  try {\n    ensureDataFile();\n    const content = fs.readFileSync(warningsFile, 'utf8');\n    return JSON.parse(content);\n  } catch (error) {\n    console.error('Error loading warnings, resetting file:', error.message);\n    fs.writeFileSync(warningsFile, JSON.stringify({}));\n    return {};\n  }\n}\n\nfunction saveWarnings(data) {\n  try {\n    fs.writeFileSync(warningsFile, JSON.stringify(data, null, 2));\n  } catch (error) {\n    console.error('Error saving warnings:', error.message);\n    throw error;\n  }\n}\n\nexport async function warnUser(sock, msg) {\n  try {\n    const from = msg.key.remoteJid;\n    const mentioned = msg.message.extendedTextMessage?.contextInfo?.mentionedJid;\n    if (!mentioned || mentioned.length === 0) return await sock.sendMessage(from, { text: 'âŒ Mention a user to warn!' });\n\n    const data = loadWarnings();\n\n    for (let user of mentioned) {\n      if (!data[from]) data[from] = {};\n      if (!data[from][user]) data[from][user] = 0;\n      data[from][user] += 1;\n\n      await sock.sendMessage(from, { text: `âš ï¸ <@${user.split('@')[0]}> has been warned! Total warnings: ${data[from][user]}` });\n    }\n\n    saveWarnings(data);\n  } catch (error) {\n    console.error('Error in warnUser:', error.message);\n    await sock.sendMessage(msg.key.remoteJid, { text: 'âŒ Failed to warn user. Please try again.' });\n  }\n}\n\nexport async function checkWarnings(sock, msg) {\n  try {\n    const from = msg.key.remoteJid;\n    const mentioned = msg.message.extendedTextMessage?.contextInfo?.mentionedJid;\n    \n    if (!mentioned || mentioned.length === 0) {\n      return await sock.sendMessage(from, { text: 'âŒ Mention a user to check warnings!' });\n    }\n\n    const data = loadWarnings();\n\n    for (let user of mentioned) {\n      const count = data[from]?.[user] || 0;\n      await sock.sendMessage(from, { text: `âš ï¸ <@${user.split('@')[0]}> has ${count} warning(s)` });\n    }\n  } catch (error) {\n    console.error('Error in checkWarnings:', error.message);\n    await sock.sendMessage(msg.key.remoteJid, { text: 'âŒ Failed to check warnings. Please try again.' });\n  }\n}\n","size_bytes":2546},"commands/welcome.js":{"content":"import fs from 'fs';\nconst welcomeFile = 'data/welcome.json';\n\nfunction ensureWelcomeFile() {\n  try {\n    const dir = 'data';\n    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });\n    if (!fs.existsSync(welcomeFile)) fs.writeFileSync(welcomeFile, JSON.stringify({}));\n  } catch (error) {\n    console.error('Error creating welcome file:', error.message);\n  }\n}\n\nfunction loadWelcomeData() {\n  try {\n    ensureWelcomeFile();\n    const content = fs.readFileSync(welcomeFile, 'utf8');\n    return JSON.parse(content);\n  } catch (error) {\n    console.error('Error loading welcome data, resetting file:', error.message);\n    fs.writeFileSync(welcomeFile, JSON.stringify({}));\n    return {};\n  }\n}\n\nexport async function welcomeMessage(sock, participant) {\n  try {\n    const from = participant.id.split('-')[0] + '@g.us';\n    const data = loadWelcomeData();\n    const customMsg = data[from]?.welcome || 'ğŸ‘‹ Welcome to the group!';\n    \n    await sock.sendMessage(from, { text: `${customMsg}\\n@${participant.id.split('@')[0]}`, mentions: [participant.id] });\n  } catch (error) {\n    console.error('Error sending welcome message:', error.message);\n  }\n}\n\nexport async function goodbyeMessage(sock, participant) {\n  try {\n    const from = participant.id.split('-')[0] + '@g.us';\n    const data = loadWelcomeData();\n    const customMsg = data[from]?.goodbye || 'ğŸ‘‹ Goodbye!';\n\n    await sock.sendMessage(from, { text: `${customMsg}\\n@${participant.id.split('@')[0]}`, mentions: [participant.id] });\n  } catch (error) {\n    console.error('Error sending goodbye message:', error.message);\n  }\n}\n","size_bytes":1600},"utils/handler.js":{"content":"","size_bytes":0},"utils/logger.js":{"content":"","size_bytes":0},"commands/botmode.js":{"content":"import chalk from 'chalk';\nimport fs from 'fs';\nimport path from 'path';\n\nconst STATE_FILE = path.join('data', 'bot_state.json');\n\n// Load bot state\nfunction loadState() {\n  try {\n    if (fs.existsSync(STATE_FILE)) {\n      const data = fs.readFileSync(STATE_FILE, 'utf8');\n      return JSON.parse(data);\n    }\n  } catch (error) {\n    console.log(chalk.red('Error loading bot state:'), error.message);\n  }\n  return { privateMode: false, ownerJid: null, sudoUsers: [] };\n}\n\n// Save bot state\nfunction saveState(state) {\n  try {\n    fs.writeFileSync(STATE_FILE, JSON.stringify(state, null, 2), 'utf8');\n  } catch (error) {\n    console.log(chalk.red('Error saving bot state:'), error.message);\n  }\n}\n\n// Get normalized JID (remove device suffix)\nexport function getNormalizedJid(jid) {\n  if (!jid) return null;\n  return jid.split(':')[0];\n}\n\n// Check if user is owner\nexport function isOwner(userJid) {\n  const state = loadState();\n  if (!state.ownerJid) return false;\n  \n  const normalizedUser = getNormalizedJid(userJid);\n  const normalizedOwner = getNormalizedJid(state.ownerJid);\n  \n  // Also check if the user number matches the owner number (handle different JID formats)\n  const userNumber = normalizedUser.split('@')[0];\n  const ownerNumber = normalizedOwner.split('@')[0];\n  \n  return normalizedUser === normalizedOwner || userNumber === ownerNumber;\n}\n\n// Check if user is sudo\nexport function isSudo(userJid) {\n  const state = loadState();\n  const normalizedUser = getNormalizedJid(userJid);\n  return state.sudoUsers.some(sudo => getNormalizedJid(sudo) === normalizedUser);\n}\n\n// Check if user has access\nexport function hasAccess(userJid) {\n  const state = loadState();\n  if (!state.privateMode) return true; // Public mode - everyone has access\n  return isOwner(userJid) || isSudo(userJid);\n}\n\n// Initialize owner from socket\nexport function initializeOwner(sock) {\n  const state = loadState();\n  if (!state.ownerJid && sock.user && sock.user.id) {\n    state.ownerJid = getNormalizedJid(sock.user.id);\n    saveState(state);\n    console.log(chalk.green(`âœ… Bot owner initialized: ${state.ownerJid}`));\n  }\n}\n\n// Set private mode\nexport async function setPrivateMode(sock, msg, enablePrivate) {\n  const from = msg.key.remoteJid;\n  const userJid = msg.key.participant || msg.key.remoteJid;\n  \n  if (!isOwner(userJid)) {\n    await sock.sendMessage(from, { \n      text: 'â›” *Access Denied*\\n\\nğŸ” Only my supreme master can control my privacy settings.\\n\\n_You dare challenge the authority of Saitama?_ ğŸ’ª' \n    });\n    return;\n  }\n  \n  const state = loadState();\n  state.privateMode = enablePrivate;\n  saveState(state);\n  \n  if (enablePrivate) {\n    await sock.sendMessage(from, { \n      text: 'ğŸ”’ *PRIVATE MODE ACTIVATED*\\n\\nâš¡ The bot is now in exclusive mode.\\n\\nOnly authorized users can use my commands.\\n\\n_The power is now restricted..._ ğŸ›¡ï¸' \n    });\n  } else {\n    await sock.sendMessage(from, { \n      text: 'ğŸŒ *PUBLIC MODE ACTIVATED*\\n\\nâš¡ The bot is now open to everyone.\\n\\nAll users can freely use my commands.\\n\\n_The power flows freely once more..._ âœ¨' \n    });\n  }\n}\n\n// Get access denied message\nexport function getAccessDeniedMessage() {\n  const messages = [\n    'â›” *ACCESS DENIED*\\n\\nğŸ” This bot is currently in *PRIVATE MODE*.\\n\\nOnly my supreme master has the authority to command me.\\n\\n_You shall not pass..._ âš”ï¸',\n    'â›” *HALT!*\\n\\nğŸ›¡ï¸ I serve only one master in private mode.\\n\\n_Your commands fall on deaf ears..._ ğŸ‘Š',\n    'â›” *RESTRICTED ACCESS*\\n\\nâš¡ The bot is locked for unauthorized users.\\n\\nMy master alone holds the key.\\n\\n_Know your place..._ ğŸ’¥'\n  ];\n  return messages[Math.floor(Math.random() * messages.length)];\n}\n\n// Get current mode status\nexport function getModeStatus() {\n  const state = loadState();\n  return state.privateMode ? 'ğŸ”’ Private Mode' : 'ğŸŒ Public Mode';\n}\n\n// Add sudo user\nexport async function addSudoUser(sock, msg) {\n  const from = msg.key.remoteJid;\n  const userJid = msg.key.participant || msg.key.remoteJid;\n  \n  if (!isOwner(userJid)) {\n    await sock.sendMessage(from, { \n      text: 'â›” *Access Denied*\\n\\nOnly the bot owner can add sudo users.' \n    });\n    return;\n  }\n  \n  const mentionedJid = msg.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0];\n  if (!mentionedJid) {\n    await sock.sendMessage(from, { \n      text: 'âŒ Please mention a user to add as sudo.\\n\\n*Example:* .sudo @user' \n    });\n    return;\n  }\n  \n  const state = loadState();\n  const normalizedJid = getNormalizedJid(mentionedJid);\n  \n  if (state.sudoUsers.includes(normalizedJid)) {\n    await sock.sendMessage(from, { \n      text: 'âœ… User is already a sudo user.' \n    });\n    return;\n  }\n  \n  state.sudoUsers.push(normalizedJid);\n  saveState(state);\n  \n  await sock.sendMessage(from, { \n    text: `âœ… *Sudo Access Granted*\\n\\nğŸ” User has been elevated to sudo status.\\n\\nThey can now use commands even in private mode.` \n  });\n}\n","size_bytes":4939},"commands/presence.js":{"content":"// Store presence states\nlet alwaysOnline = false;  // Disabled\nlet autoTyping = false;    // Disabled\n\nexport async function toggleAlwaysOnline(sock, msg) {\n  const from = msg.key.remoteJid;\n  alwaysOnline = !alwaysOnline;\n  \n  if (alwaysOnline) {\n    await sock.sendMessage(from, { text: 'âœ… *Always Online Mode: ENABLED*\\n\\nBot will appear online at all times.' });\n  } else {\n    await sock.sendMessage(from, { text: 'âŒ *Always Online Mode: DISABLED*\\n\\nBot status will return to normal.' });\n  }\n}\n\nexport async function toggleAutoTyping(sock, msg) {\n  const from = msg.key.remoteJid;\n  autoTyping = !autoTyping;\n  \n  if (autoTyping) {\n    await sock.sendMessage(from, { text: 'âœ… *Auto Typing Mode: ENABLED*\\n\\nBot will show typing indicator on incoming messages.' });\n  } else {\n    await sock.sendMessage(from, { text: 'âŒ *Auto Typing Mode: DISABLED*\\n\\nTyping indicator will return to normal.' });\n  }\n}\n\nexport async function handlePresence(sock, from) {\n  // Send typing indicator if auto typing is enabled\n  if (autoTyping && from) {\n    try {\n      await sock.sendPresenceUpdate('composing', from);\n      // Stop typing after 3 seconds\n      setTimeout(async () => {\n        try {\n          await sock.sendPresenceUpdate('paused', from);\n        } catch (error) {\n          // Silently fail if connection is not ready\n        }\n      }, 3000);\n    } catch (error) {\n      // Silently fail if connection is not ready\n    }\n  }\n}\n\nexport async function maintainOnlineStatus(sock) {\n  if (alwaysOnline) {\n    try {\n      await sock.sendPresenceUpdate('available');\n    } catch (error) {\n      // Silently fail if connection is not ready\n      throw error; // Re-throw to be caught by interval handler\n    }\n  }\n}\n\nexport function getPresenceStatus() {\n  return { alwaysOnline, autoTyping };\n}\n","size_bytes":1809},"commands/autoreply.js":{"content":"/**\n * Auto-Reply System - Respond when owner is away\n */\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst AUTO_REPLY_FILE = path.join('data', 'autoreply.json');\n\nfunction loadAutoReply() {\n  try {\n    if (!fs.existsSync('data')) fs.mkdirSync('data', { recursive: true });\n    if (fs.existsSync(AUTO_REPLY_FILE)) {\n      return JSON.parse(fs.readFileSync(AUTO_REPLY_FILE, 'utf8'));\n    }\n  } catch (error) {\n    console.error('Error loading auto-reply:', error.message);\n  }\n  return { enabled: false, message: '' };\n}\n\nfunction saveAutoReply(data) {\n  try {\n    fs.writeFileSync(AUTO_REPLY_FILE, JSON.stringify(data, null, 2));\n  } catch (error) {\n    console.error('Error saving auto-reply:', error.message);\n  }\n}\n\nexport async function setAutoReply(sock, msg) {\n  const from = msg.key.remoteJid;\n  const text = msg.message?.conversation || msg.message?.extendedTextMessage?.text || '';\n  \n  const isOwner = msg.key.fromMe;\n  if (!isOwner) {\n    return await sock.sendMessage(from, { \n      text: 'â›” *Access Denied*\\n\\nOnly the bot owner can manage auto-reply.' \n    });\n  }\n  \n  const args = text.split(' ').slice(1);\n  const action = args[0]?.toLowerCase();\n  \n  if (action === 'on' || action === 'enable') {\n    const replyMsg = args.slice(1).join(' ') || 'ğŸ¤– I\\'m currently away. I\\'ll respond as soon as possible!';\n    saveAutoReply({ enabled: true, message: replyMsg });\n    await sock.sendMessage(from, { \n      text: `âœ… *Auto-Reply Enabled*\\n\\nğŸ“ Message:\\n\"${replyMsg}\"` \n    });\n  } \n  else if (action === 'off' || action === 'disable') {\n    saveAutoReply({ enabled: false, message: '' });\n    await sock.sendMessage(from, { \n      text: 'âŒ *Auto-Reply Disabled*' \n    });\n  } \n  else if (action === 'status') {\n    const config = loadAutoReply();\n    await sock.sendMessage(from, { \n      text: `ğŸ“Š *Auto-Reply Status*\\n\\n${config.enabled ? 'âœ… Enabled' : 'âŒ Disabled'}\\n\\n${config.enabled ? `ğŸ“ Message: \"${config.message}\"` : ''}` \n    });\n  } \n  else {\n    await sock.sendMessage(from, { \n      text: 'âŒ *Invalid Command*\\n\\nUsage:\\n`.autoreply on <message>` - Enable auto-reply\\n`.autoreply off` - Disable auto-reply\\n`.autoreply status` - Check status' \n    });\n  }\n}\n\nexport async function handleAutoReply(sock, msg) {\n  if (msg.key.fromMe) return;\n  \n  const config = loadAutoReply();\n  if (!config.enabled) return;\n  \n  const from = msg.key.remoteJid;\n  \n  try {\n    await sock.sendMessage(from, { text: config.message });\n  } catch (error) {\n    console.error('Auto-reply failed:', error.message);\n  }\n}\n\nexport function isAutoReplyEnabled() {\n  const config = loadAutoReply();\n  return config.enabled;\n}\n","size_bytes":2654},"commands/broadcast.js":{"content":"/**\n * Broadcast System - Send announcements to multiple groups\n */\n\nexport default async function broadcast(sock, msg) {\n  const from = msg.key.remoteJid;\n  const text = msg.message?.conversation || msg.message?.extendedTextMessage?.text || '';\n  \n  const isOwner = msg.key.fromMe;\n  if (!isOwner) {\n    return await sock.sendMessage(from, { \n      text: 'â›” *Access Denied*\\n\\nOnly the bot owner can use broadcast commands.' \n    });\n  }\n  \n  const broadcastMsg = text.replace(/^\\.(broadcast|bc)\\s*/i, '').trim();\n  \n  if (!broadcastMsg) {\n    return await sock.sendMessage(from, { \n      text: 'âŒ *Broadcast Message Required*\\n\\nUsage: `.broadcast <message>`\\n\\nExample: `.broadcast Important update for all groups!`' \n    });\n  }\n  \n  try {\n    const groups = await sock.groupFetchAllParticipating();\n    const groupJids = Object.keys(groups);\n    \n    if (groupJids.length === 0) {\n      return await sock.sendMessage(from, { \n        text: 'âš ï¸ *No Groups Found*\\n\\nThe bot is not in any groups yet.' \n      });\n    }\n    \n    await sock.sendMessage(from, { \n      text: `ğŸ“¡ *Broadcasting to ${groupJids.length} groups...*\\n\\nPlease wait...` \n    });\n    \n    let successCount = 0;\n    let failCount = 0;\n    \n    for (const groupJid of groupJids) {\n      try {\n        await sock.sendMessage(groupJid, { \n          text: `ğŸ“¢ *BROADCAST MESSAGE*\\n\\n${broadcastMsg}\\n\\n_â€” Saitama Bot Announcement_` \n        });\n        successCount++;\n        await new Promise(r => setTimeout(r, 1000));\n      } catch (error) {\n        failCount++;\n        console.error(`Failed to broadcast to ${groupJid}:`, error.message);\n      }\n    }\n    \n    await sock.sendMessage(from, { \n      text: `âœ… *Broadcast Complete*\\n\\nğŸ“¤ Sent: ${successCount}\\nâŒ Failed: ${failCount}\\nğŸ“Š Total Groups: ${groupJids.length}` \n    });\n    \n  } catch (error) {\n    await sock.sendMessage(from, { \n      text: `âŒ *Broadcast Failed*\\n\\n${error.message}` \n    });\n  }\n}\n","size_bytes":1960},"commands/reminders.js":{"content":"/**\n * Reminder System - Set timed reminders\n */\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst REMINDERS_FILE = path.join('data', 'reminders.json');\nconst activeReminders = new Map();\n\nfunction loadReminders() {\n  try {\n    if (!fs.existsSync('data')) fs.mkdirSync('data', { recursive: true });\n    if (fs.existsSync(REMINDERS_FILE)) {\n      return JSON.parse(fs.readFileSync(REMINDERS_FILE, 'utf8'));\n    }\n  } catch (error) {\n    console.error('Error loading reminders:', error.message);\n  }\n  return [];\n}\n\nfunction saveReminders(reminders) {\n  try {\n    fs.writeFileSync(REMINDERS_FILE, JSON.stringify(reminders, null, 2));\n  } catch (error) {\n    console.error('Error saving reminders:', error.message);\n  }\n}\n\nexport function initReminders(sock) {\n  const reminders = loadReminders();\n  const now = Date.now();\n  \n  reminders.forEach(reminder => {\n    if (reminder.time > now) {\n      scheduleReminder(sock, reminder);\n    }\n  });\n  \n  const activeCount = reminders.filter(r => r.time > now).length;\n  console.log(`âœ… Loaded ${activeCount} active reminders`);\n}\n\nfunction scheduleReminder(sock, reminder) {\n  const delay = reminder.time - Date.now();\n  \n  if (delay <= 0) return;\n  \n  const timeoutId = setTimeout(async () => {\n    try {\n      await sock.sendMessage(reminder.chatJid, { \n        text: `â° *REMINDER*\\n\\nğŸ“ ${reminder.message}\\n\\n_Set ${formatTimeDiff(reminder.setTime)}_` \n      });\n      \n      const reminders = loadReminders();\n      const filtered = reminders.filter(r => r.id !== reminder.id);\n      saveReminders(filtered);\n      activeReminders.delete(reminder.id);\n    } catch (error) {\n      console.error('Failed to send reminder:', error.message);\n    }\n  }, delay);\n  \n  activeReminders.set(reminder.id, timeoutId);\n}\n\nfunction formatTimeDiff(timestamp) {\n  const diff = Date.now() - timestamp;\n  const minutes = Math.floor(diff / 60000);\n  const hours = Math.floor(minutes / 60);\n  const days = Math.floor(hours / 24);\n  \n  if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;\n  if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;\n  if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;\n  return 'just now';\n}\n\nexport async function setReminder(sock, msg) {\n  const from = msg.key.remoteJid;\n  const text = msg.message?.conversation || msg.message?.extendedTextMessage?.text || '';\n  \n  const match = text.match(/^\\.remind(?:er)?\\s+(\\d+)([smhd])\\s+(.+)$/i);\n  \n  if (!match) {\n    return await sock.sendMessage(from, { \n      text: 'âŒ *Invalid Format*\\n\\nUsage: `.remind <time><unit> <message>`\\n\\nExamples:\\n`.remind 30s Check the oven`\\n`.remind 5m Meeting starts`\\n`.remind 2h Take a break`\\n`.remind 1d Pay bills`\\n\\nUnits: s=seconds, m=minutes, h=hours, d=days' \n    });\n  }\n  \n  const [, amount, unit, message] = match;\n  const multipliers = { s: 1000, m: 60000, h: 3600000, d: 86400000 };\n  const delay = parseInt(amount) * multipliers[unit.toLowerCase()];\n  \n  if (delay < 1000 || delay > 7 * 86400000) {\n    return await sock.sendMessage(from, { \n      text: 'âŒ *Invalid Time*\\n\\nReminder must be between 1 second and 7 days.' \n    });\n  }\n  \n  const reminder = {\n    id: Date.now().toString() + Math.random().toString(36).substr(2, 9),\n    chatJid: from,\n    message: message.trim(),\n    time: Date.now() + delay,\n    setTime: Date.now()\n  };\n  \n  const reminders = loadReminders();\n  reminders.push(reminder);\n  saveReminders(reminders);\n  \n  scheduleReminder(sock, reminder);\n  \n  const timeStr = `${amount}${unit}`;\n  await sock.sendMessage(from, { \n    text: `âœ… *Reminder Set*\\n\\nâ° Time: ${timeStr}\\nğŸ“ Message: \"${message}\"\\n\\nI'll remind you!` \n  });\n}\n\nexport async function listReminders(sock, msg) {\n  const from = msg.key.remoteJid;\n  const reminders = loadReminders().filter(r => r.chatJid === from && r.time > Date.now());\n  \n  if (reminders.length === 0) {\n    return await sock.sendMessage(from, { \n      text: 'ğŸ“­ *No Active Reminders*\\n\\nSet one with `.remind <time> <message>`' \n    });\n  }\n  \n  let list = 'â° *Your Active Reminders*\\n\\n';\n  reminders.forEach((r, i) => {\n    const timeLeft = r.time - Date.now();\n    const minutes = Math.ceil(timeLeft / 60000);\n    list += `${i + 1}. \"${r.message}\"\\n   â±ï¸ In ${minutes} minute${minutes !== 1 ? 's' : ''}\\n\\n`;\n  });\n  \n  await sock.sendMessage(from, { text: list });\n}\n","size_bytes":4357},"commands/stats.js":{"content":"/**\n * Bot Statistics - Show usage analytics\n */\n\nimport { getStats } from '../utils/analytics.js';\nimport { getRateLimitInfo } from '../utils/rateLimiter.js';\nimport os from 'os';\n\nfunction formatUptime(seconds) {\n  const days = Math.floor(seconds / 86400);\n  const hours = Math.floor((seconds % 86400) / 3600);\n  const mins = Math.floor((seconds % 3600) / 60);\n  return `${days}d ${hours}h ${mins}m`;\n}\n\nexport default async function stats(sock, msg) {\n  const from = msg.key.remoteJid;\n  \n  const isOwner = msg.key.fromMe;\n  if (!isOwner) {\n    return await sock.sendMessage(from, { \n      text: 'â›” *Access Denied*\\n\\nOnly the bot owner can view statistics.' \n    });\n  }\n  \n  try {\n    const analytics = getStats();\n    const rateInfo = getRateLimitInfo();\n    const uptime = formatUptime(process.uptime());\n    const memUsage = (process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2);\n    \n    let statsMsg = `ğŸ“Š *SAITAMA BOT STATISTICS*\\n\\n`;\n    statsMsg += `â±ï¸ *Uptime:* ${uptime}\\n`;\n    statsMsg += `ğŸ’¾ *Memory:* ${memUsage} MB\\n`;\n    statsMsg += `ğŸ–¥ï¸ *Platform:* ${os.platform()}\\n\\n`;\n    \n    statsMsg += `ğŸ“ˆ *Usage Analytics*\\n`;\n    statsMsg += `â”œ Total Commands: ${analytics.totalCommands}\\n`;\n    statsMsg += `â”œ Unique Users: ${analytics.uniqueUsers}\\n`;\n    statsMsg += `â”” Unique Groups: ${analytics.uniqueGroups}\\n\\n`;\n    \n    statsMsg += `ğŸ”¥ *Top Commands*\\n`;\n    if (analytics.topCommands.length > 0) {\n      analytics.topCommands.slice(0, 5).forEach((cmd, i) => {\n        statsMsg += `${i + 1}. ${cmd.command} - ${cmd.count}Ã—\\n`;\n      });\n    } else {\n      statsMsg += `No commands tracked yet\\n`;\n    }\n    \n    statsMsg += `\\nğŸ›¡ï¸ *Rate Limiting*\\n`;\n    statsMsg += `â”œ Max: ${rateInfo.maxCommands} cmds/${rateInfo.windowSeconds}s\\n`;\n    statsMsg += `â”œ Cooldown: ${rateInfo.cooldownSeconds}s\\n`;\n    statsMsg += `â”” Tracked Users: ${rateInfo.trackedUsers}\\n`;\n    \n    statsMsg += `\\n_Analytics since ${new Date(analytics.startDate).toLocaleDateString()}_`;\n    \n    await sock.sendMessage(from, { text: statsMsg });\n  } catch (error) {\n    await sock.sendMessage(from, { \n      text: `âŒ *Error Loading Stats*\\n\\n${error.message}` \n    });\n  }\n}\n","size_bytes":2213},"utils/analytics.js":{"content":"/**\n * Bot Analytics - Track usage statistics\n */\n\nimport fs from 'fs';\nimport path from 'path';\n\nconst STATS_FILE = path.join('data', 'analytics.json');\n\nfunction loadStats() {\n  try {\n    if (!fs.existsSync('data')) fs.mkdirSync('data', { recursive: true });\n    if (fs.existsSync(STATS_FILE)) {\n      return JSON.parse(fs.readFileSync(STATS_FILE, 'utf8'));\n    }\n  } catch (error) {\n    console.error('Error loading analytics:', error.message);\n  }\n  return {\n    totalCommands: 0,\n    commandCounts: {},\n    userCounts: {},\n    groupCounts: {},\n    startDate: new Date().toISOString()\n  };\n}\n\nfunction saveStats(stats) {\n  try {\n    fs.writeFileSync(STATS_FILE, JSON.stringify(stats, null, 2));\n  } catch (error) {\n    console.error('Error saving analytics:', error.message);\n  }\n}\n\nexport function trackCommand(command, userJid, groupJid = null) {\n  const stats = loadStats();\n  \n  stats.totalCommands++;\n  \n  stats.commandCounts[command] = (stats.commandCounts[command] || 0) + 1;\n  \n  stats.userCounts[userJid] = (stats.userCounts[userJid] || 0) + 1;\n  \n  if (groupJid) {\n    stats.groupCounts[groupJid] = (stats.groupCounts[groupJid] || 0) + 1;\n  }\n  \n  saveStats(stats);\n}\n\nexport function getStats() {\n  const stats = loadStats();\n  \n  const topCommands = Object.entries(stats.commandCounts)\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 10)\n    .map(([cmd, count]) => ({ command: cmd, count }));\n  \n  const topUsers = Object.entries(stats.userCounts)\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 10)\n    .map(([user, count]) => ({ user, count }));\n  \n  return {\n    totalCommands: stats.totalCommands,\n    uniqueUsers: Object.keys(stats.userCounts).length,\n    uniqueGroups: Object.keys(stats.groupCounts).length,\n    topCommands,\n    topUsers,\n    startDate: stats.startDate\n  };\n}\n\nexport function resetStats() {\n  if (fs.existsSync(STATS_FILE)) {\n    fs.unlinkSync(STATS_FILE);\n  }\n  return true;\n}\n","size_bytes":1916},"utils/rateLimiter.js":{"content":"/**\n * Rate Limiter - Prevents spam and abuse\n * Tracks command usage per user and enforces limits\n */\n\nconst userCommands = new Map();\nconst RATE_LIMIT = {\n  maxCommands: 10,\n  windowMs: 60000,\n  cooldown: 3000\n};\n\nexport function checkRateLimit(userJid) {\n  const now = Date.now();\n  \n  if (!userCommands.has(userJid)) {\n    userCommands.set(userJid, { count: 1, firstCommand: now, lastCommand: now });\n    return { allowed: true, remaining: RATE_LIMIT.maxCommands - 1 };\n  }\n  \n  const userData = userCommands.get(userJid);\n  \n  if (now - userData.lastCommand < RATE_LIMIT.cooldown) {\n    return { \n      allowed: false, \n      reason: 'cooldown',\n      waitTime: Math.ceil((RATE_LIMIT.cooldown - (now - userData.lastCommand)) / 1000)\n    };\n  }\n  \n  if (now - userData.firstCommand > RATE_LIMIT.windowMs) {\n    userData.count = 1;\n    userData.firstCommand = now;\n    userData.lastCommand = now;\n    return { allowed: true, remaining: RATE_LIMIT.maxCommands - 1 };\n  }\n  \n  if (userData.count >= RATE_LIMIT.maxCommands) {\n    const resetTime = Math.ceil((RATE_LIMIT.windowMs - (now - userData.firstCommand)) / 1000);\n    return { \n      allowed: false, \n      reason: 'limit',\n      resetTime \n    };\n  }\n  \n  userData.count++;\n  userData.lastCommand = now;\n  return { allowed: true, remaining: RATE_LIMIT.maxCommands - userData.count };\n}\n\nexport function resetRateLimit(userJid) {\n  userCommands.delete(userJid);\n}\n\nexport function getRateLimitInfo() {\n  return {\n    maxCommands: RATE_LIMIT.maxCommands,\n    windowSeconds: RATE_LIMIT.windowMs / 1000,\n    cooldownSeconds: RATE_LIMIT.cooldown / 1000,\n    trackedUsers: userCommands.size\n  };\n}\n","size_bytes":1650}},"version":1}